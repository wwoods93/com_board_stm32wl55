
com_board_CM0PLUS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08020000  08020000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001828  080200c0  080200c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000090  080218e8  080218e8  000118e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08021978  08021978  00018014  2**0
                  CONTENTS
  4 .ARM          00000000  08021978  08021978  00018014  2**0
                  CONTENTS
  5 .preinit_array 00000000  08021978  08021978  00018014  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08021978  08021978  00011978  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0802197c  0802197c  0001197c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000014  20008000  08021980  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000021c  20008014  08021994  00018014  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20008230  08021994  00018230  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00018014  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  0001803c  2**0
                  CONTENTS, READONLY
 13 .debug_info   00009511  00000000  00000000  0001807f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00001c96  00000000  00000000  00021590  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000b20  00000000  00000000  00023228  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000869  00000000  00000000  00023d48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0001bd85  00000000  00000000  000245b1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000d1fc  00000000  00000000  00040336  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000b3fb9  00000000  00000000  0004d532  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00002694  00000000  00000000  001014ec  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000059  00000000  00000000  00103b80  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080200c0 <__do_global_dtors_aux>:
 80200c0:	b510      	push	{r4, lr}
 80200c2:	4c06      	ldr	r4, [pc, #24]	; (80200dc <__do_global_dtors_aux+0x1c>)
 80200c4:	7823      	ldrb	r3, [r4, #0]
 80200c6:	2b00      	cmp	r3, #0
 80200c8:	d107      	bne.n	80200da <__do_global_dtors_aux+0x1a>
 80200ca:	4b05      	ldr	r3, [pc, #20]	; (80200e0 <__do_global_dtors_aux+0x20>)
 80200cc:	2b00      	cmp	r3, #0
 80200ce:	d002      	beq.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d0:	4804      	ldr	r0, [pc, #16]	; (80200e4 <__do_global_dtors_aux+0x24>)
 80200d2:	e000      	b.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d4:	bf00      	nop
 80200d6:	2301      	movs	r3, #1
 80200d8:	7023      	strb	r3, [r4, #0]
 80200da:	bd10      	pop	{r4, pc}
 80200dc:	20008014 	.word	0x20008014
 80200e0:	00000000 	.word	0x00000000
 80200e4:	080218d0 	.word	0x080218d0

080200e8 <frame_dummy>:
 80200e8:	4b04      	ldr	r3, [pc, #16]	; (80200fc <frame_dummy+0x14>)
 80200ea:	b510      	push	{r4, lr}
 80200ec:	2b00      	cmp	r3, #0
 80200ee:	d003      	beq.n	80200f8 <frame_dummy+0x10>
 80200f0:	4903      	ldr	r1, [pc, #12]	; (8020100 <frame_dummy+0x18>)
 80200f2:	4804      	ldr	r0, [pc, #16]	; (8020104 <frame_dummy+0x1c>)
 80200f4:	e000      	b.n	80200f8 <frame_dummy+0x10>
 80200f6:	bf00      	nop
 80200f8:	bd10      	pop	{r4, pc}
 80200fa:	46c0      	nop			; (mov r8, r8)
 80200fc:	00000000 	.word	0x00000000
 8020100:	20008018 	.word	0x20008018
 8020104:	080218d0 	.word	0x080218d0

08020108 <__udivsi3>:
 8020108:	2200      	movs	r2, #0
 802010a:	0843      	lsrs	r3, r0, #1
 802010c:	428b      	cmp	r3, r1
 802010e:	d374      	bcc.n	80201fa <__udivsi3+0xf2>
 8020110:	0903      	lsrs	r3, r0, #4
 8020112:	428b      	cmp	r3, r1
 8020114:	d35f      	bcc.n	80201d6 <__udivsi3+0xce>
 8020116:	0a03      	lsrs	r3, r0, #8
 8020118:	428b      	cmp	r3, r1
 802011a:	d344      	bcc.n	80201a6 <__udivsi3+0x9e>
 802011c:	0b03      	lsrs	r3, r0, #12
 802011e:	428b      	cmp	r3, r1
 8020120:	d328      	bcc.n	8020174 <__udivsi3+0x6c>
 8020122:	0c03      	lsrs	r3, r0, #16
 8020124:	428b      	cmp	r3, r1
 8020126:	d30d      	bcc.n	8020144 <__udivsi3+0x3c>
 8020128:	22ff      	movs	r2, #255	; 0xff
 802012a:	0209      	lsls	r1, r1, #8
 802012c:	ba12      	rev	r2, r2
 802012e:	0c03      	lsrs	r3, r0, #16
 8020130:	428b      	cmp	r3, r1
 8020132:	d302      	bcc.n	802013a <__udivsi3+0x32>
 8020134:	1212      	asrs	r2, r2, #8
 8020136:	0209      	lsls	r1, r1, #8
 8020138:	d065      	beq.n	8020206 <__udivsi3+0xfe>
 802013a:	0b03      	lsrs	r3, r0, #12
 802013c:	428b      	cmp	r3, r1
 802013e:	d319      	bcc.n	8020174 <__udivsi3+0x6c>
 8020140:	e000      	b.n	8020144 <__udivsi3+0x3c>
 8020142:	0a09      	lsrs	r1, r1, #8
 8020144:	0bc3      	lsrs	r3, r0, #15
 8020146:	428b      	cmp	r3, r1
 8020148:	d301      	bcc.n	802014e <__udivsi3+0x46>
 802014a:	03cb      	lsls	r3, r1, #15
 802014c:	1ac0      	subs	r0, r0, r3
 802014e:	4152      	adcs	r2, r2
 8020150:	0b83      	lsrs	r3, r0, #14
 8020152:	428b      	cmp	r3, r1
 8020154:	d301      	bcc.n	802015a <__udivsi3+0x52>
 8020156:	038b      	lsls	r3, r1, #14
 8020158:	1ac0      	subs	r0, r0, r3
 802015a:	4152      	adcs	r2, r2
 802015c:	0b43      	lsrs	r3, r0, #13
 802015e:	428b      	cmp	r3, r1
 8020160:	d301      	bcc.n	8020166 <__udivsi3+0x5e>
 8020162:	034b      	lsls	r3, r1, #13
 8020164:	1ac0      	subs	r0, r0, r3
 8020166:	4152      	adcs	r2, r2
 8020168:	0b03      	lsrs	r3, r0, #12
 802016a:	428b      	cmp	r3, r1
 802016c:	d301      	bcc.n	8020172 <__udivsi3+0x6a>
 802016e:	030b      	lsls	r3, r1, #12
 8020170:	1ac0      	subs	r0, r0, r3
 8020172:	4152      	adcs	r2, r2
 8020174:	0ac3      	lsrs	r3, r0, #11
 8020176:	428b      	cmp	r3, r1
 8020178:	d301      	bcc.n	802017e <__udivsi3+0x76>
 802017a:	02cb      	lsls	r3, r1, #11
 802017c:	1ac0      	subs	r0, r0, r3
 802017e:	4152      	adcs	r2, r2
 8020180:	0a83      	lsrs	r3, r0, #10
 8020182:	428b      	cmp	r3, r1
 8020184:	d301      	bcc.n	802018a <__udivsi3+0x82>
 8020186:	028b      	lsls	r3, r1, #10
 8020188:	1ac0      	subs	r0, r0, r3
 802018a:	4152      	adcs	r2, r2
 802018c:	0a43      	lsrs	r3, r0, #9
 802018e:	428b      	cmp	r3, r1
 8020190:	d301      	bcc.n	8020196 <__udivsi3+0x8e>
 8020192:	024b      	lsls	r3, r1, #9
 8020194:	1ac0      	subs	r0, r0, r3
 8020196:	4152      	adcs	r2, r2
 8020198:	0a03      	lsrs	r3, r0, #8
 802019a:	428b      	cmp	r3, r1
 802019c:	d301      	bcc.n	80201a2 <__udivsi3+0x9a>
 802019e:	020b      	lsls	r3, r1, #8
 80201a0:	1ac0      	subs	r0, r0, r3
 80201a2:	4152      	adcs	r2, r2
 80201a4:	d2cd      	bcs.n	8020142 <__udivsi3+0x3a>
 80201a6:	09c3      	lsrs	r3, r0, #7
 80201a8:	428b      	cmp	r3, r1
 80201aa:	d301      	bcc.n	80201b0 <__udivsi3+0xa8>
 80201ac:	01cb      	lsls	r3, r1, #7
 80201ae:	1ac0      	subs	r0, r0, r3
 80201b0:	4152      	adcs	r2, r2
 80201b2:	0983      	lsrs	r3, r0, #6
 80201b4:	428b      	cmp	r3, r1
 80201b6:	d301      	bcc.n	80201bc <__udivsi3+0xb4>
 80201b8:	018b      	lsls	r3, r1, #6
 80201ba:	1ac0      	subs	r0, r0, r3
 80201bc:	4152      	adcs	r2, r2
 80201be:	0943      	lsrs	r3, r0, #5
 80201c0:	428b      	cmp	r3, r1
 80201c2:	d301      	bcc.n	80201c8 <__udivsi3+0xc0>
 80201c4:	014b      	lsls	r3, r1, #5
 80201c6:	1ac0      	subs	r0, r0, r3
 80201c8:	4152      	adcs	r2, r2
 80201ca:	0903      	lsrs	r3, r0, #4
 80201cc:	428b      	cmp	r3, r1
 80201ce:	d301      	bcc.n	80201d4 <__udivsi3+0xcc>
 80201d0:	010b      	lsls	r3, r1, #4
 80201d2:	1ac0      	subs	r0, r0, r3
 80201d4:	4152      	adcs	r2, r2
 80201d6:	08c3      	lsrs	r3, r0, #3
 80201d8:	428b      	cmp	r3, r1
 80201da:	d301      	bcc.n	80201e0 <__udivsi3+0xd8>
 80201dc:	00cb      	lsls	r3, r1, #3
 80201de:	1ac0      	subs	r0, r0, r3
 80201e0:	4152      	adcs	r2, r2
 80201e2:	0883      	lsrs	r3, r0, #2
 80201e4:	428b      	cmp	r3, r1
 80201e6:	d301      	bcc.n	80201ec <__udivsi3+0xe4>
 80201e8:	008b      	lsls	r3, r1, #2
 80201ea:	1ac0      	subs	r0, r0, r3
 80201ec:	4152      	adcs	r2, r2
 80201ee:	0843      	lsrs	r3, r0, #1
 80201f0:	428b      	cmp	r3, r1
 80201f2:	d301      	bcc.n	80201f8 <__udivsi3+0xf0>
 80201f4:	004b      	lsls	r3, r1, #1
 80201f6:	1ac0      	subs	r0, r0, r3
 80201f8:	4152      	adcs	r2, r2
 80201fa:	1a41      	subs	r1, r0, r1
 80201fc:	d200      	bcs.n	8020200 <__udivsi3+0xf8>
 80201fe:	4601      	mov	r1, r0
 8020200:	4152      	adcs	r2, r2
 8020202:	4610      	mov	r0, r2
 8020204:	4770      	bx	lr
 8020206:	e7ff      	b.n	8020208 <__udivsi3+0x100>
 8020208:	b501      	push	{r0, lr}
 802020a:	2000      	movs	r0, #0
 802020c:	f000 f806 	bl	802021c <__aeabi_idiv0>
 8020210:	bd02      	pop	{r1, pc}
 8020212:	46c0      	nop			; (mov r8, r8)

08020214 <__aeabi_uidivmod>:
 8020214:	2900      	cmp	r1, #0
 8020216:	d0f7      	beq.n	8020208 <__udivsi3+0x100>
 8020218:	e776      	b.n	8020108 <__udivsi3>
 802021a:	4770      	bx	lr

0802021c <__aeabi_idiv0>:
 802021c:	4770      	bx	lr
 802021e:	46c0      	nop			; (mov r8, r8)

08020220 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8020220:	b580      	push	{r7, lr}
 8020222:	af00      	add	r7, sp, #0

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 8020224:	46c0      	nop			; (mov r8, r8)
 8020226:	46bd      	mov	sp, r7
 8020228:	bd80      	pop	{r7, pc}

0802022a <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 802022a:	b580      	push	{r7, lr}
 802022c:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 802022e:	f000 f8af 	bl	8020390 <HAL_Init>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
    MX_LoRaWAN_Process();
 8020232:	f001 f9d1 	bl	80215d8 <MX_LoRaWAN_Process>
 8020236:	e7fc      	b.n	8020232 <main+0x8>

08020238 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8020238:	b580      	push	{r7, lr}
 802023a:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/
  /* SVC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVC_IRQn, 2, 0);
 802023c:	2305      	movs	r3, #5
 802023e:	425b      	negs	r3, r3
 8020240:	2200      	movs	r2, #0
 8020242:	2102      	movs	r1, #2
 8020244:	0018      	movs	r0, r3
 8020246:	f000 f9ad 	bl	80205a4 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 2, 0);
 802024a:	2302      	movs	r3, #2
 802024c:	425b      	negs	r3, r3
 802024e:	2200      	movs	r2, #0
 8020250:	2102      	movs	r1, #2
 8020252:	0018      	movs	r0, r3
 8020254:	f000 f9a6 	bl	80205a4 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8020258:	46c0      	nop			; (mov r8, r8)
 802025a:	46bd      	mov	sp, r7
 802025c:	bd80      	pop	{r7, pc}

0802025e <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 802025e:	b580      	push	{r7, lr}
 8020260:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8020262:	e7fe      	b.n	8020262 <NMI_Handler+0x4>

08020264 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8020264:	b580      	push	{r7, lr}
 8020266:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8020268:	e7fe      	b.n	8020268 <HardFault_Handler+0x4>

0802026a <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 802026a:	b580      	push	{r7, lr}
 802026c:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 802026e:	46c0      	nop			; (mov r8, r8)
 8020270:	46bd      	mov	sp, r7
 8020272:	bd80      	pop	{r7, pc}

08020274 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8020274:	b580      	push	{r7, lr}
 8020276:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8020278:	46c0      	nop			; (mov r8, r8)
 802027a:	46bd      	mov	sp, r7
 802027c:	bd80      	pop	{r7, pc}

0802027e <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 802027e:	b580      	push	{r7, lr}
 8020280:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8020282:	f000 f8eb 	bl	802045c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8020286:	46c0      	nop			; (mov r8, r8)
 8020288:	46bd      	mov	sp, r7
 802028a:	bd80      	pop	{r7, pc}

0802028c <IPCC_C2_RX_C2_TX_IRQHandler>:

/**
  * @brief This function handles IPCC RX Occupied and TX Free Interrupt.
  */
void IPCC_C2_RX_C2_TX_IRQHandler(void)
{
 802028c:	b580      	push	{r7, lr}
 802028e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN IPCC_C2_RX_C2_TX_IRQn 0 */

  /* USER CODE END IPCC_C2_RX_C2_TX_IRQn 0 */
  HAL_IPCC_RX_IRQHandler(&hipcc);
 8020290:	4b05      	ldr	r3, [pc, #20]	; (80202a8 <IPCC_C2_RX_C2_TX_IRQHandler+0x1c>)
 8020292:	0018      	movs	r0, r3
 8020294:	f001 f81a 	bl	80212cc <HAL_IPCC_RX_IRQHandler>
  HAL_IPCC_TX_IRQHandler(&hipcc);
 8020298:	4b03      	ldr	r3, [pc, #12]	; (80202a8 <IPCC_C2_RX_C2_TX_IRQHandler+0x1c>)
 802029a:	0018      	movs	r0, r3
 802029c:	f000 ffc6 	bl	802122c <HAL_IPCC_TX_IRQHandler>
  /* USER CODE BEGIN IPCC_C2_RX_C2_TX_IRQn 1 */

  /* USER CODE END IPCC_C2_RX_C2_TX_IRQn 1 */
}
 80202a0:	46c0      	nop			; (mov r8, r8)
 80202a2:	46bd      	mov	sp, r7
 80202a4:	bd80      	pop	{r7, pc}
 80202a6:	46c0      	nop			; (mov r8, r8)
 80202a8:	200081bc 	.word	0x200081bc

080202ac <I2C1_IRQHandler>:

/**
  * @brief This function handles I2C1 Event and Error Interrupt.
  */
void I2C1_IRQHandler(void)
{
 80202ac:	b580      	push	{r7, lr}
 80202ae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_IRQn 0 */

  /* USER CODE END I2C1_IRQn 0 */
  if (hi2c1.Instance->ISR & (I2C_FLAG_BERR | I2C_FLAG_ARLO | I2C_FLAG_OVR)) {
 80202b0:	4b09      	ldr	r3, [pc, #36]	; (80202d8 <I2C1_IRQHandler+0x2c>)
 80202b2:	681b      	ldr	r3, [r3, #0]
 80202b4:	699a      	ldr	r2, [r3, #24]
 80202b6:	23e0      	movs	r3, #224	; 0xe0
 80202b8:	00db      	lsls	r3, r3, #3
 80202ba:	4013      	ands	r3, r2
 80202bc:	d004      	beq.n	80202c8 <I2C1_IRQHandler+0x1c>
    HAL_I2C_ER_IRQHandler(&hi2c1);
 80202be:	4b06      	ldr	r3, [pc, #24]	; (80202d8 <I2C1_IRQHandler+0x2c>)
 80202c0:	0018      	movs	r0, r3
 80202c2:	f000 fa1f 	bl	8020704 <HAL_I2C_ER_IRQHandler>
    HAL_I2C_EV_IRQHandler(&hi2c1);
  }
  /* USER CODE BEGIN I2C1_IRQn 1 */

  /* USER CODE END I2C1_IRQn 1 */
}
 80202c6:	e003      	b.n	80202d0 <I2C1_IRQHandler+0x24>
    HAL_I2C_EV_IRQHandler(&hi2c1);
 80202c8:	4b03      	ldr	r3, [pc, #12]	; (80202d8 <I2C1_IRQHandler+0x2c>)
 80202ca:	0018      	movs	r0, r3
 80202cc:	f000 fa00 	bl	80206d0 <HAL_I2C_EV_IRQHandler>
}
 80202d0:	46c0      	nop			; (mov r8, r8)
 80202d2:	46bd      	mov	sp, r7
 80202d4:	bd80      	pop	{r7, pc}
 80202d6:	46c0      	nop			; (mov r8, r8)
 80202d8:	20008030 	.word	0x20008030

080202dc <I2C2_IRQHandler>:

/**
  * @brief This function handles I2C2 Event and Error Interrupt.
  */
void I2C2_IRQHandler(void)
{
 80202dc:	b580      	push	{r7, lr}
 80202de:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C2_IRQn 0 */

  /* USER CODE END I2C2_IRQn 0 */
  if (hi2c2.Instance->ISR & (I2C_FLAG_BERR | I2C_FLAG_ARLO | I2C_FLAG_OVR)) {
 80202e0:	4b09      	ldr	r3, [pc, #36]	; (8020308 <I2C2_IRQHandler+0x2c>)
 80202e2:	681b      	ldr	r3, [r3, #0]
 80202e4:	699a      	ldr	r2, [r3, #24]
 80202e6:	23e0      	movs	r3, #224	; 0xe0
 80202e8:	00db      	lsls	r3, r3, #3
 80202ea:	4013      	ands	r3, r2
 80202ec:	d004      	beq.n	80202f8 <I2C2_IRQHandler+0x1c>
    HAL_I2C_ER_IRQHandler(&hi2c2);
 80202ee:	4b06      	ldr	r3, [pc, #24]	; (8020308 <I2C2_IRQHandler+0x2c>)
 80202f0:	0018      	movs	r0, r3
 80202f2:	f000 fa07 	bl	8020704 <HAL_I2C_ER_IRQHandler>
    HAL_I2C_EV_IRQHandler(&hi2c2);
  }
  /* USER CODE BEGIN I2C2_IRQn 1 */

  /* USER CODE END I2C2_IRQn 1 */
}
 80202f6:	e003      	b.n	8020300 <I2C2_IRQHandler+0x24>
    HAL_I2C_EV_IRQHandler(&hi2c2);
 80202f8:	4b03      	ldr	r3, [pc, #12]	; (8020308 <I2C2_IRQHandler+0x2c>)
 80202fa:	0018      	movs	r0, r3
 80202fc:	f000 f9e8 	bl	80206d0 <HAL_I2C_EV_IRQHandler>
}
 8020300:	46c0      	nop			; (mov r8, r8)
 8020302:	46bd      	mov	sp, r7
 8020304:	bd80      	pop	{r7, pc}
 8020306:	46c0      	nop			; (mov r8, r8)
 8020308:	200080b4 	.word	0x200080b4

0802030c <I2C3_IRQHandler>:

/**
  * @brief This function handles I2C3 Event and Error Interrupt.
  */
void I2C3_IRQHandler(void)
{
 802030c:	b580      	push	{r7, lr}
 802030e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C3_IRQn 0 */

  /* USER CODE END I2C3_IRQn 0 */
  if (hi2c3.Instance->ISR & (I2C_FLAG_BERR | I2C_FLAG_ARLO | I2C_FLAG_OVR)) {
 8020310:	4b09      	ldr	r3, [pc, #36]	; (8020338 <I2C3_IRQHandler+0x2c>)
 8020312:	681b      	ldr	r3, [r3, #0]
 8020314:	699a      	ldr	r2, [r3, #24]
 8020316:	23e0      	movs	r3, #224	; 0xe0
 8020318:	00db      	lsls	r3, r3, #3
 802031a:	4013      	ands	r3, r2
 802031c:	d004      	beq.n	8020328 <I2C3_IRQHandler+0x1c>
    HAL_I2C_ER_IRQHandler(&hi2c3);
 802031e:	4b06      	ldr	r3, [pc, #24]	; (8020338 <I2C3_IRQHandler+0x2c>)
 8020320:	0018      	movs	r0, r3
 8020322:	f000 f9ef 	bl	8020704 <HAL_I2C_ER_IRQHandler>
    HAL_I2C_EV_IRQHandler(&hi2c3);
  }
  /* USER CODE BEGIN I2C3_IRQn 1 */

  /* USER CODE END I2C3_IRQn 1 */
}
 8020326:	e003      	b.n	8020330 <I2C3_IRQHandler+0x24>
    HAL_I2C_EV_IRQHandler(&hi2c3);
 8020328:	4b03      	ldr	r3, [pc, #12]	; (8020338 <I2C3_IRQHandler+0x2c>)
 802032a:	0018      	movs	r0, r3
 802032c:	f000 f9d0 	bl	80206d0 <HAL_I2C_EV_IRQHandler>
}
 8020330:	46c0      	nop			; (mov r8, r8)
 8020332:	46bd      	mov	sp, r7
 8020334:	bd80      	pop	{r7, pc}
 8020336:	46c0      	nop			; (mov r8, r8)
 8020338:	20008138 	.word	0x20008138

0802033c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 802033c:	480d      	ldr	r0, [pc, #52]	; (8020374 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 802033e:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 8020340:	f7ff ff6e 	bl	8020220 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8020344:	480c      	ldr	r0, [pc, #48]	; (8020378 <LoopForever+0x6>)
  ldr r1, =_edata
 8020346:	490d      	ldr	r1, [pc, #52]	; (802037c <LoopForever+0xa>)
  ldr r2, =_sidata
 8020348:	4a0d      	ldr	r2, [pc, #52]	; (8020380 <LoopForever+0xe>)
  movs r3, #0
 802034a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 802034c:	e002      	b.n	8020354 <LoopCopyDataInit>

0802034e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 802034e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8020350:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8020352:	3304      	adds	r3, #4

08020354 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8020354:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8020356:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8020358:	d3f9      	bcc.n	802034e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 802035a:	4a0a      	ldr	r2, [pc, #40]	; (8020384 <LoopForever+0x12>)
  ldr r4, =_ebss
 802035c:	4c0a      	ldr	r4, [pc, #40]	; (8020388 <LoopForever+0x16>)
  movs r3, #0
 802035e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8020360:	e001      	b.n	8020366 <LoopFillZerobss>

08020362 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8020362:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8020364:	3204      	adds	r2, #4

08020366 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8020366:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8020368:	d3fb      	bcc.n	8020362 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 802036a:	f001 fa8d 	bl	8021888 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 802036e:	f7ff ff5c 	bl	802022a <main>

08020372 <LoopForever>:

LoopForever:
    b LoopForever
 8020372:	e7fe      	b.n	8020372 <LoopForever>
  ldr   r0, =_estack
 8020374:	20010000 	.word	0x20010000
  ldr r0, =_sdata
 8020378:	20008000 	.word	0x20008000
  ldr r1, =_edata
 802037c:	20008014 	.word	0x20008014
  ldr r2, =_sidata
 8020380:	08021980 	.word	0x08021980
  ldr r2, =_sbss
 8020384:	20008014 	.word	0x20008014
  ldr r4, =_ebss
 8020388:	20008230 	.word	0x20008230

0802038c <ADC_COMP_DAC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 802038c:	e7fe      	b.n	802038c <ADC_COMP_DAC_IRQHandler>
	...

08020390 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8020390:	b580      	push	{r7, lr}
 8020392:	b082      	sub	sp, #8
 8020394:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 8020396:	1dfb      	adds	r3, r7, #7
 8020398:	2200      	movs	r2, #0
 802039a:	701a      	strb	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
#endif

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
 802039c:	f001 f904 	bl	80215a8 <HAL_RCC_GetHCLK2Freq>
 80203a0:	0002      	movs	r2, r0
 80203a2:	4b09      	ldr	r3, [pc, #36]	; (80203c8 <HAL_Init+0x38>)
 80203a4:	601a      	str	r2, [r3, #0]
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80203a6:	2003      	movs	r0, #3
 80203a8:	f000 f810 	bl	80203cc <HAL_InitTick>
 80203ac:	1e03      	subs	r3, r0, #0
 80203ae:	d003      	beq.n	80203b8 <HAL_Init+0x28>
  {
    status = HAL_ERROR;
 80203b0:	1dfb      	adds	r3, r7, #7
 80203b2:	2201      	movs	r2, #1
 80203b4:	701a      	strb	r2, [r3, #0]
 80203b6:	e001      	b.n	80203bc <HAL_Init+0x2c>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 80203b8:	f7ff ff3e 	bl	8020238 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 80203bc:	1dfb      	adds	r3, r7, #7
 80203be:	781b      	ldrb	r3, [r3, #0]
}
 80203c0:	0018      	movs	r0, r3
 80203c2:	46bd      	mov	sp, r7
 80203c4:	b002      	add	sp, #8
 80203c6:	bd80      	pop	{r7, pc}
 80203c8:	20008000 	.word	0x20008000

080203cc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80203cc:	b590      	push	{r4, r7, lr}
 80203ce:	b085      	sub	sp, #20
 80203d0:	af00      	add	r7, sp, #0
 80203d2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 80203d4:	230f      	movs	r3, #15
 80203d6:	18fb      	adds	r3, r7, r3
 80203d8:	2200      	movs	r2, #0
 80203da:	701a      	strb	r2, [r3, #0]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 80203dc:	4b1d      	ldr	r3, [pc, #116]	; (8020454 <HAL_InitTick+0x88>)
 80203de:	781b      	ldrb	r3, [r3, #0]
 80203e0:	2b00      	cmp	r3, #0
 80203e2:	d02c      	beq.n	802043e <HAL_InitTick+0x72>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
#ifdef CORE_CM0PLUS
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLK2Freq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
 80203e4:	f001 f8e0 	bl	80215a8 <HAL_RCC_GetHCLK2Freq>
 80203e8:	0004      	movs	r4, r0
 80203ea:	4b1a      	ldr	r3, [pc, #104]	; (8020454 <HAL_InitTick+0x88>)
 80203ec:	781b      	ldrb	r3, [r3, #0]
 80203ee:	0019      	movs	r1, r3
 80203f0:	23fa      	movs	r3, #250	; 0xfa
 80203f2:	0098      	lsls	r0, r3, #2
 80203f4:	f7ff fe88 	bl	8020108 <__udivsi3>
 80203f8:	0003      	movs	r3, r0
 80203fa:	0019      	movs	r1, r3
 80203fc:	0020      	movs	r0, r4
 80203fe:	f7ff fe83 	bl	8020108 <__udivsi3>
 8020402:	0003      	movs	r3, r0
 8020404:	0018      	movs	r0, r3
 8020406:	f000 f8e2 	bl	80205ce <HAL_SYSTICK_Config>
 802040a:	1e03      	subs	r3, r0, #0
 802040c:	d112      	bne.n	8020434 <HAL_InitTick+0x68>
#else
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
#endif
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 802040e:	687b      	ldr	r3, [r7, #4]
 8020410:	2b03      	cmp	r3, #3
 8020412:	d80a      	bhi.n	802042a <HAL_InitTick+0x5e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8020414:	6879      	ldr	r1, [r7, #4]
 8020416:	2301      	movs	r3, #1
 8020418:	425b      	negs	r3, r3
 802041a:	2200      	movs	r2, #0
 802041c:	0018      	movs	r0, r3
 802041e:	f000 f8c1 	bl	80205a4 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8020422:	4b0d      	ldr	r3, [pc, #52]	; (8020458 <HAL_InitTick+0x8c>)
 8020424:	687a      	ldr	r2, [r7, #4]
 8020426:	601a      	str	r2, [r3, #0]
 8020428:	e00d      	b.n	8020446 <HAL_InitTick+0x7a>
      }
      else
      {
        status = HAL_ERROR;
 802042a:	230f      	movs	r3, #15
 802042c:	18fb      	adds	r3, r7, r3
 802042e:	2201      	movs	r2, #1
 8020430:	701a      	strb	r2, [r3, #0]
 8020432:	e008      	b.n	8020446 <HAL_InitTick+0x7a>
      }
    }
    else
    {
      status = HAL_ERROR;
 8020434:	230f      	movs	r3, #15
 8020436:	18fb      	adds	r3, r7, r3
 8020438:	2201      	movs	r2, #1
 802043a:	701a      	strb	r2, [r3, #0]
 802043c:	e003      	b.n	8020446 <HAL_InitTick+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
 802043e:	230f      	movs	r3, #15
 8020440:	18fb      	adds	r3, r7, r3
 8020442:	2201      	movs	r2, #1
 8020444:	701a      	strb	r2, [r3, #0]
  }

  /* Return function status */
  return status;
 8020446:	230f      	movs	r3, #15
 8020448:	18fb      	adds	r3, r7, r3
 802044a:	781b      	ldrb	r3, [r3, #0]
}
 802044c:	0018      	movs	r0, r3
 802044e:	46bd      	mov	sp, r7
 8020450:	b005      	add	sp, #20
 8020452:	bd90      	pop	{r4, r7, pc}
 8020454:	20008008 	.word	0x20008008
 8020458:	20008004 	.word	0x20008004

0802045c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 802045c:	b580      	push	{r7, lr}
 802045e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8020460:	4b05      	ldr	r3, [pc, #20]	; (8020478 <HAL_IncTick+0x1c>)
 8020462:	781b      	ldrb	r3, [r3, #0]
 8020464:	001a      	movs	r2, r3
 8020466:	4b05      	ldr	r3, [pc, #20]	; (802047c <HAL_IncTick+0x20>)
 8020468:	681b      	ldr	r3, [r3, #0]
 802046a:	18d2      	adds	r2, r2, r3
 802046c:	4b03      	ldr	r3, [pc, #12]	; (802047c <HAL_IncTick+0x20>)
 802046e:	601a      	str	r2, [r3, #0]
}
 8020470:	46c0      	nop			; (mov r8, r8)
 8020472:	46bd      	mov	sp, r7
 8020474:	bd80      	pop	{r7, pc}
 8020476:	46c0      	nop			; (mov r8, r8)
 8020478:	20008008 	.word	0x20008008
 802047c:	200081f8 	.word	0x200081f8

08020480 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8020480:	b590      	push	{r4, r7, lr}
 8020482:	b083      	sub	sp, #12
 8020484:	af00      	add	r7, sp, #0
 8020486:	0002      	movs	r2, r0
 8020488:	6039      	str	r1, [r7, #0]
 802048a:	1dfb      	adds	r3, r7, #7
 802048c:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 802048e:	1dfb      	adds	r3, r7, #7
 8020490:	781b      	ldrb	r3, [r3, #0]
 8020492:	2b7f      	cmp	r3, #127	; 0x7f
 8020494:	d828      	bhi.n	80204e8 <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8020496:	4a2f      	ldr	r2, [pc, #188]	; (8020554 <__NVIC_SetPriority+0xd4>)
 8020498:	1dfb      	adds	r3, r7, #7
 802049a:	781b      	ldrb	r3, [r3, #0]
 802049c:	b25b      	sxtb	r3, r3
 802049e:	089b      	lsrs	r3, r3, #2
 80204a0:	33c0      	adds	r3, #192	; 0xc0
 80204a2:	009b      	lsls	r3, r3, #2
 80204a4:	589b      	ldr	r3, [r3, r2]
 80204a6:	1dfa      	adds	r2, r7, #7
 80204a8:	7812      	ldrb	r2, [r2, #0]
 80204aa:	0011      	movs	r1, r2
 80204ac:	2203      	movs	r2, #3
 80204ae:	400a      	ands	r2, r1
 80204b0:	00d2      	lsls	r2, r2, #3
 80204b2:	21ff      	movs	r1, #255	; 0xff
 80204b4:	4091      	lsls	r1, r2
 80204b6:	000a      	movs	r2, r1
 80204b8:	43d2      	mvns	r2, r2
 80204ba:	401a      	ands	r2, r3
 80204bc:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80204be:	683b      	ldr	r3, [r7, #0]
 80204c0:	019b      	lsls	r3, r3, #6
 80204c2:	22ff      	movs	r2, #255	; 0xff
 80204c4:	401a      	ands	r2, r3
 80204c6:	1dfb      	adds	r3, r7, #7
 80204c8:	781b      	ldrb	r3, [r3, #0]
 80204ca:	0018      	movs	r0, r3
 80204cc:	2303      	movs	r3, #3
 80204ce:	4003      	ands	r3, r0
 80204d0:	00db      	lsls	r3, r3, #3
 80204d2:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80204d4:	481f      	ldr	r0, [pc, #124]	; (8020554 <__NVIC_SetPriority+0xd4>)
 80204d6:	1dfb      	adds	r3, r7, #7
 80204d8:	781b      	ldrb	r3, [r3, #0]
 80204da:	b25b      	sxtb	r3, r3
 80204dc:	089b      	lsrs	r3, r3, #2
 80204de:	430a      	orrs	r2, r1
 80204e0:	33c0      	adds	r3, #192	; 0xc0
 80204e2:	009b      	lsls	r3, r3, #2
 80204e4:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 80204e6:	e031      	b.n	802054c <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80204e8:	4a1b      	ldr	r2, [pc, #108]	; (8020558 <__NVIC_SetPriority+0xd8>)
 80204ea:	1dfb      	adds	r3, r7, #7
 80204ec:	781b      	ldrb	r3, [r3, #0]
 80204ee:	0019      	movs	r1, r3
 80204f0:	230f      	movs	r3, #15
 80204f2:	400b      	ands	r3, r1
 80204f4:	3b08      	subs	r3, #8
 80204f6:	089b      	lsrs	r3, r3, #2
 80204f8:	3306      	adds	r3, #6
 80204fa:	009b      	lsls	r3, r3, #2
 80204fc:	18d3      	adds	r3, r2, r3
 80204fe:	3304      	adds	r3, #4
 8020500:	681b      	ldr	r3, [r3, #0]
 8020502:	1dfa      	adds	r2, r7, #7
 8020504:	7812      	ldrb	r2, [r2, #0]
 8020506:	0011      	movs	r1, r2
 8020508:	2203      	movs	r2, #3
 802050a:	400a      	ands	r2, r1
 802050c:	00d2      	lsls	r2, r2, #3
 802050e:	21ff      	movs	r1, #255	; 0xff
 8020510:	4091      	lsls	r1, r2
 8020512:	000a      	movs	r2, r1
 8020514:	43d2      	mvns	r2, r2
 8020516:	401a      	ands	r2, r3
 8020518:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 802051a:	683b      	ldr	r3, [r7, #0]
 802051c:	019b      	lsls	r3, r3, #6
 802051e:	22ff      	movs	r2, #255	; 0xff
 8020520:	401a      	ands	r2, r3
 8020522:	1dfb      	adds	r3, r7, #7
 8020524:	781b      	ldrb	r3, [r3, #0]
 8020526:	0018      	movs	r0, r3
 8020528:	2303      	movs	r3, #3
 802052a:	4003      	ands	r3, r0
 802052c:	00db      	lsls	r3, r3, #3
 802052e:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8020530:	4809      	ldr	r0, [pc, #36]	; (8020558 <__NVIC_SetPriority+0xd8>)
 8020532:	1dfb      	adds	r3, r7, #7
 8020534:	781b      	ldrb	r3, [r3, #0]
 8020536:	001c      	movs	r4, r3
 8020538:	230f      	movs	r3, #15
 802053a:	4023      	ands	r3, r4
 802053c:	3b08      	subs	r3, #8
 802053e:	089b      	lsrs	r3, r3, #2
 8020540:	430a      	orrs	r2, r1
 8020542:	3306      	adds	r3, #6
 8020544:	009b      	lsls	r3, r3, #2
 8020546:	18c3      	adds	r3, r0, r3
 8020548:	3304      	adds	r3, #4
 802054a:	601a      	str	r2, [r3, #0]
}
 802054c:	46c0      	nop			; (mov r8, r8)
 802054e:	46bd      	mov	sp, r7
 8020550:	b003      	add	sp, #12
 8020552:	bd90      	pop	{r4, r7, pc}
 8020554:	e000e100 	.word	0xe000e100
 8020558:	e000ed00 	.word	0xe000ed00

0802055c <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 802055c:	b580      	push	{r7, lr}
 802055e:	b082      	sub	sp, #8
 8020560:	af00      	add	r7, sp, #0
 8020562:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8020564:	687b      	ldr	r3, [r7, #4]
 8020566:	1e5a      	subs	r2, r3, #1
 8020568:	2380      	movs	r3, #128	; 0x80
 802056a:	045b      	lsls	r3, r3, #17
 802056c:	429a      	cmp	r2, r3
 802056e:	d301      	bcc.n	8020574 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 8020570:	2301      	movs	r3, #1
 8020572:	e010      	b.n	8020596 <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8020574:	4b0a      	ldr	r3, [pc, #40]	; (80205a0 <SysTick_Config+0x44>)
 8020576:	687a      	ldr	r2, [r7, #4]
 8020578:	3a01      	subs	r2, #1
 802057a:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 802057c:	2301      	movs	r3, #1
 802057e:	425b      	negs	r3, r3
 8020580:	2103      	movs	r1, #3
 8020582:	0018      	movs	r0, r3
 8020584:	f7ff ff7c 	bl	8020480 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8020588:	4b05      	ldr	r3, [pc, #20]	; (80205a0 <SysTick_Config+0x44>)
 802058a:	2200      	movs	r2, #0
 802058c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 802058e:	4b04      	ldr	r3, [pc, #16]	; (80205a0 <SysTick_Config+0x44>)
 8020590:	2207      	movs	r2, #7
 8020592:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8020594:	2300      	movs	r3, #0
}
 8020596:	0018      	movs	r0, r3
 8020598:	46bd      	mov	sp, r7
 802059a:	b002      	add	sp, #8
 802059c:	bd80      	pop	{r7, pc}
 802059e:	46c0      	nop			; (mov r8, r8)
 80205a0:	e000e010 	.word	0xe000e010

080205a4 <HAL_NVIC_SetPriority>:
  *         with stm32wlxx devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80205a4:	b580      	push	{r7, lr}
 80205a6:	b084      	sub	sp, #16
 80205a8:	af00      	add	r7, sp, #0
 80205aa:	60b9      	str	r1, [r7, #8]
 80205ac:	607a      	str	r2, [r7, #4]
 80205ae:	210f      	movs	r1, #15
 80205b0:	187b      	adds	r3, r7, r1
 80205b2:	1c02      	adds	r2, r0, #0
 80205b4:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
 80205b6:	68ba      	ldr	r2, [r7, #8]
 80205b8:	187b      	adds	r3, r7, r1
 80205ba:	781b      	ldrb	r3, [r3, #0]
 80205bc:	b25b      	sxtb	r3, r3
 80205be:	0011      	movs	r1, r2
 80205c0:	0018      	movs	r0, r3
 80205c2:	f7ff ff5d 	bl	8020480 <__NVIC_SetPriority>
}
 80205c6:	46c0      	nop			; (mov r8, r8)
 80205c8:	46bd      	mov	sp, r7
 80205ca:	b004      	add	sp, #16
 80205cc:	bd80      	pop	{r7, pc}

080205ce <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80205ce:	b580      	push	{r7, lr}
 80205d0:	b082      	sub	sp, #8
 80205d2:	af00      	add	r7, sp, #0
 80205d4:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 80205d6:	687b      	ldr	r3, [r7, #4]
 80205d8:	0018      	movs	r0, r3
 80205da:	f7ff ffbf 	bl	802055c <SysTick_Config>
 80205de:	0003      	movs	r3, r0
}
 80205e0:	0018      	movs	r0, r3
 80205e2:	46bd      	mov	sp, r7
 80205e4:	b002      	add	sp, #8
 80205e6:	bd80      	pop	{r7, pc}

080205e8 <HAL_DMA_Abort_IT>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *             the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 80205e8:	b580      	push	{r7, lr}
 80205ea:	b084      	sub	sp, #16
 80205ec:	af00      	add	r7, sp, #0
 80205ee:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80205f0:	210f      	movs	r1, #15
 80205f2:	187b      	adds	r3, r7, r1
 80205f4:	2200      	movs	r2, #0
 80205f6:	701a      	strb	r2, [r3, #0]

  if (hdma->State != HAL_DMA_STATE_BUSY)
 80205f8:	687b      	ldr	r3, [r7, #4]
 80205fa:	2225      	movs	r2, #37	; 0x25
 80205fc:	5c9b      	ldrb	r3, [r3, r2]
 80205fe:	b2db      	uxtb	r3, r3
 8020600:	2b02      	cmp	r3, #2
 8020602:	d006      	beq.n	8020612 <HAL_DMA_Abort_IT+0x2a>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8020604:	687b      	ldr	r3, [r7, #4]
 8020606:	2204      	movs	r2, #4
 8020608:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 802060a:	187b      	adds	r3, r7, r1
 802060c:	2201      	movs	r2, #1
 802060e:	701a      	strb	r2, [r3, #0]
 8020610:	e048      	b.n	80206a4 <HAL_DMA_Abort_IT+0xbc>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8020612:	687b      	ldr	r3, [r7, #4]
 8020614:	681b      	ldr	r3, [r3, #0]
 8020616:	681a      	ldr	r2, [r3, #0]
 8020618:	687b      	ldr	r3, [r7, #4]
 802061a:	681b      	ldr	r3, [r3, #0]
 802061c:	210e      	movs	r1, #14
 802061e:	438a      	bics	r2, r1
 8020620:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 8020622:	687b      	ldr	r3, [r7, #4]
 8020624:	681b      	ldr	r3, [r3, #0]
 8020626:	681a      	ldr	r2, [r3, #0]
 8020628:	687b      	ldr	r3, [r7, #4]
 802062a:	681b      	ldr	r3, [r3, #0]
 802062c:	2101      	movs	r1, #1
 802062e:	438a      	bics	r2, r1
 8020630:	601a      	str	r2, [r3, #0]

    /* disable the DMAMUX sync overrun IT*/
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8020632:	687b      	ldr	r3, [r7, #4]
 8020634:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8020636:	681a      	ldr	r2, [r3, #0]
 8020638:	687b      	ldr	r3, [r7, #4]
 802063a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802063c:	491d      	ldr	r1, [pc, #116]	; (80206b4 <HAL_DMA_Abort_IT+0xcc>)
 802063e:	400a      	ands	r2, r1
 8020640:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8020642:	687b      	ldr	r3, [r7, #4]
 8020644:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020646:	221c      	movs	r2, #28
 8020648:	401a      	ands	r2, r3
 802064a:	687b      	ldr	r3, [r7, #4]
 802064c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802064e:	2101      	movs	r1, #1
 8020650:	4091      	lsls	r1, r2
 8020652:	000a      	movs	r2, r1
 8020654:	605a      	str	r2, [r3, #4]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8020656:	687b      	ldr	r3, [r7, #4]
 8020658:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802065a:	687a      	ldr	r2, [r7, #4]
 802065c:	6d12      	ldr	r2, [r2, #80]	; 0x50
 802065e:	605a      	str	r2, [r3, #4]

    if (hdma->DMAmuxRequestGen != NULL)
 8020660:	687b      	ldr	r3, [r7, #4]
 8020662:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8020664:	2b00      	cmp	r3, #0
 8020666:	d00c      	beq.n	8020682 <HAL_DMA_Abort_IT+0x9a>
    {
      /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
      /* disable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8020668:	687b      	ldr	r3, [r7, #4]
 802066a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802066c:	681a      	ldr	r2, [r3, #0]
 802066e:	687b      	ldr	r3, [r7, #4]
 8020670:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8020672:	4910      	ldr	r1, [pc, #64]	; (80206b4 <HAL_DMA_Abort_IT+0xcc>)
 8020674:	400a      	ands	r2, r1
 8020676:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8020678:	687b      	ldr	r3, [r7, #4]
 802067a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802067c:	687a      	ldr	r2, [r7, #4]
 802067e:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8020680:	605a      	str	r2, [r3, #4]
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8020682:	687b      	ldr	r3, [r7, #4]
 8020684:	2225      	movs	r2, #37	; 0x25
 8020686:	2101      	movs	r1, #1
 8020688:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 802068a:	687b      	ldr	r3, [r7, #4]
 802068c:	2224      	movs	r2, #36	; 0x24
 802068e:	2100      	movs	r1, #0
 8020690:	5499      	strb	r1, [r3, r2]

    /* Call User Abort callback */
    if (hdma->XferAbortCallback != NULL)
 8020692:	687b      	ldr	r3, [r7, #4]
 8020694:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020696:	2b00      	cmp	r3, #0
 8020698:	d004      	beq.n	80206a4 <HAL_DMA_Abort_IT+0xbc>
    {
      hdma->XferAbortCallback(hdma);
 802069a:	687b      	ldr	r3, [r7, #4]
 802069c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802069e:	687a      	ldr	r2, [r7, #4]
 80206a0:	0010      	movs	r0, r2
 80206a2:	4798      	blx	r3
    }
  }
  return status;
 80206a4:	230f      	movs	r3, #15
 80206a6:	18fb      	adds	r3, r7, r3
 80206a8:	781b      	ldrb	r3, [r3, #0]
}
 80206aa:	0018      	movs	r0, r3
 80206ac:	46bd      	mov	sp, r7
 80206ae:	b004      	add	sp, #16
 80206b0:	bd80      	pop	{r7, pc}
 80206b2:	46c0      	nop			; (mov r8, r8)
 80206b4:	fffffeff 	.word	0xfffffeff

080206b8 <HAL_DMA_GetState>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *             the configuration information for the specified DMA Channel.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
 80206b8:	b580      	push	{r7, lr}
 80206ba:	b082      	sub	sp, #8
 80206bc:	af00      	add	r7, sp, #0
 80206be:	6078      	str	r0, [r7, #4]
  /* Return DMA handle state */
  return hdma->State;
 80206c0:	687b      	ldr	r3, [r7, #4]
 80206c2:	2225      	movs	r2, #37	; 0x25
 80206c4:	5c9b      	ldrb	r3, [r3, r2]
 80206c6:	b2db      	uxtb	r3, r3
}
 80206c8:	0018      	movs	r0, r3
 80206ca:	46bd      	mov	sp, r7
 80206cc:	b002      	add	sp, #8
 80206ce:	bd80      	pop	{r7, pc}

080206d0 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 80206d0:	b580      	push	{r7, lr}
 80206d2:	b084      	sub	sp, #16
 80206d4:	af00      	add	r7, sp, #0
 80206d6:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 80206d8:	687b      	ldr	r3, [r7, #4]
 80206da:	681b      	ldr	r3, [r3, #0]
 80206dc:	699b      	ldr	r3, [r3, #24]
 80206de:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 80206e0:	687b      	ldr	r3, [r7, #4]
 80206e2:	681b      	ldr	r3, [r3, #0]
 80206e4:	681b      	ldr	r3, [r3, #0]
 80206e6:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
 80206e8:	687b      	ldr	r3, [r7, #4]
 80206ea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80206ec:	2b00      	cmp	r3, #0
 80206ee:	d005      	beq.n	80206fc <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
 80206f0:	687b      	ldr	r3, [r7, #4]
 80206f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80206f4:	68ba      	ldr	r2, [r7, #8]
 80206f6:	68f9      	ldr	r1, [r7, #12]
 80206f8:	6878      	ldr	r0, [r7, #4]
 80206fa:	4798      	blx	r3
  }
}
 80206fc:	46c0      	nop			; (mov r8, r8)
 80206fe:	46bd      	mov	sp, r7
 8020700:	b004      	add	sp, #16
 8020702:	bd80      	pop	{r7, pc}

08020704 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 8020704:	b580      	push	{r7, lr}
 8020706:	b086      	sub	sp, #24
 8020708:	af00      	add	r7, sp, #0
 802070a:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 802070c:	687b      	ldr	r3, [r7, #4]
 802070e:	681b      	ldr	r3, [r3, #0]
 8020710:	699b      	ldr	r3, [r3, #24]
 8020712:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8020714:	687b      	ldr	r3, [r7, #4]
 8020716:	681b      	ldr	r3, [r3, #0]
 8020718:	681b      	ldr	r3, [r3, #0]
 802071a:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
 802071c:	697a      	ldr	r2, [r7, #20]
 802071e:	2380      	movs	r3, #128	; 0x80
 8020720:	005b      	lsls	r3, r3, #1
 8020722:	4013      	ands	r3, r2
 8020724:	d00e      	beq.n	8020744 <HAL_I2C_ER_IRQHandler+0x40>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8020726:	693b      	ldr	r3, [r7, #16]
 8020728:	2280      	movs	r2, #128	; 0x80
 802072a:	4013      	ands	r3, r2
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
 802072c:	d00a      	beq.n	8020744 <HAL_I2C_ER_IRQHandler+0x40>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 802072e:	687b      	ldr	r3, [r7, #4]
 8020730:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020732:	2201      	movs	r2, #1
 8020734:	431a      	orrs	r2, r3
 8020736:	687b      	ldr	r3, [r7, #4]
 8020738:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 802073a:	687b      	ldr	r3, [r7, #4]
 802073c:	681b      	ldr	r3, [r3, #0]
 802073e:	2280      	movs	r2, #128	; 0x80
 8020740:	0052      	lsls	r2, r2, #1
 8020742:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
 8020744:	697a      	ldr	r2, [r7, #20]
 8020746:	2380      	movs	r3, #128	; 0x80
 8020748:	00db      	lsls	r3, r3, #3
 802074a:	4013      	ands	r3, r2
 802074c:	d00e      	beq.n	802076c <HAL_I2C_ER_IRQHandler+0x68>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 802074e:	693b      	ldr	r3, [r7, #16]
 8020750:	2280      	movs	r2, #128	; 0x80
 8020752:	4013      	ands	r3, r2
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
 8020754:	d00a      	beq.n	802076c <HAL_I2C_ER_IRQHandler+0x68>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8020756:	687b      	ldr	r3, [r7, #4]
 8020758:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802075a:	2208      	movs	r2, #8
 802075c:	431a      	orrs	r2, r3
 802075e:	687b      	ldr	r3, [r7, #4]
 8020760:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8020762:	687b      	ldr	r3, [r7, #4]
 8020764:	681b      	ldr	r3, [r3, #0]
 8020766:	2280      	movs	r2, #128	; 0x80
 8020768:	00d2      	lsls	r2, r2, #3
 802076a:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
 802076c:	697a      	ldr	r2, [r7, #20]
 802076e:	2380      	movs	r3, #128	; 0x80
 8020770:	009b      	lsls	r3, r3, #2
 8020772:	4013      	ands	r3, r2
 8020774:	d00e      	beq.n	8020794 <HAL_I2C_ER_IRQHandler+0x90>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8020776:	693b      	ldr	r3, [r7, #16]
 8020778:	2280      	movs	r2, #128	; 0x80
 802077a:	4013      	ands	r3, r2
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
 802077c:	d00a      	beq.n	8020794 <HAL_I2C_ER_IRQHandler+0x90>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 802077e:	687b      	ldr	r3, [r7, #4]
 8020780:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020782:	2202      	movs	r2, #2
 8020784:	431a      	orrs	r2, r3
 8020786:	687b      	ldr	r3, [r7, #4]
 8020788:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 802078a:	687b      	ldr	r3, [r7, #4]
 802078c:	681b      	ldr	r3, [r3, #0]
 802078e:	2280      	movs	r2, #128	; 0x80
 8020790:	0092      	lsls	r2, r2, #2
 8020792:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
 8020794:	687b      	ldr	r3, [r7, #4]
 8020796:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020798:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 802079a:	68fb      	ldr	r3, [r7, #12]
 802079c:	220b      	movs	r2, #11
 802079e:	4013      	ands	r3, r2
 80207a0:	d005      	beq.n	80207ae <HAL_I2C_ER_IRQHandler+0xaa>
  {
    I2C_ITError(hi2c, tmperror);
 80207a2:	68fa      	ldr	r2, [r7, #12]
 80207a4:	687b      	ldr	r3, [r7, #4]
 80207a6:	0011      	movs	r1, r2
 80207a8:	0018      	movs	r0, r3
 80207aa:	f000 fb8d 	bl	8020ec8 <I2C_ITError>
  }
}
 80207ae:	46c0      	nop			; (mov r8, r8)
 80207b0:	46bd      	mov	sp, r7
 80207b2:	b006      	add	sp, #24
 80207b4:	bd80      	pop	{r7, pc}
	...

080207b8 <I2C_Slave_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                          uint32_t ITSources)
{
 80207b8:	b580      	push	{r7, lr}
 80207ba:	b086      	sub	sp, #24
 80207bc:	af00      	add	r7, sp, #0
 80207be:	60f8      	str	r0, [r7, #12]
 80207c0:	60b9      	str	r1, [r7, #8]
 80207c2:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
 80207c4:	68fb      	ldr	r3, [r7, #12]
 80207c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80207c8:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
 80207ca:	68bb      	ldr	r3, [r7, #8]
 80207cc:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
 80207ce:	68fb      	ldr	r3, [r7, #12]
 80207d0:	2240      	movs	r2, #64	; 0x40
 80207d2:	5c9b      	ldrb	r3, [r3, r2]
 80207d4:	2b01      	cmp	r3, #1
 80207d6:	d101      	bne.n	80207dc <I2C_Slave_ISR_IT+0x24>
 80207d8:	2302      	movs	r3, #2
 80207da:	e0e6      	b.n	80209aa <I2C_Slave_ISR_IT+0x1f2>
 80207dc:	68fb      	ldr	r3, [r7, #12]
 80207de:	2240      	movs	r2, #64	; 0x40
 80207e0:	2101      	movs	r1, #1
 80207e2:	5499      	strb	r1, [r3, r2]

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
 80207e4:	693b      	ldr	r3, [r7, #16]
 80207e6:	2220      	movs	r2, #32
 80207e8:	4013      	ands	r3, r2
 80207ea:	d009      	beq.n	8020800 <I2C_Slave_ISR_IT+0x48>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 80207ec:	687b      	ldr	r3, [r7, #4]
 80207ee:	2220      	movs	r2, #32
 80207f0:	4013      	ands	r3, r2
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
 80207f2:	d005      	beq.n	8020800 <I2C_Slave_ISR_IT+0x48>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
 80207f4:	693a      	ldr	r2, [r7, #16]
 80207f6:	68fb      	ldr	r3, [r7, #12]
 80207f8:	0011      	movs	r1, r2
 80207fa:	0018      	movs	r0, r3
 80207fc:	f000 f9ea 	bl	8020bd4 <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
 8020800:	693b      	ldr	r3, [r7, #16]
 8020802:	2210      	movs	r2, #16
 8020804:	4013      	ands	r3, r2
 8020806:	d052      	beq.n	80208ae <I2C_Slave_ISR_IT+0xf6>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8020808:	687b      	ldr	r3, [r7, #4]
 802080a:	2210      	movs	r2, #16
 802080c:	4013      	ands	r3, r2
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
 802080e:	d04e      	beq.n	80208ae <I2C_Slave_ISR_IT+0xf6>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
 8020810:	68fb      	ldr	r3, [r7, #12]
 8020812:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020814:	b29b      	uxth	r3, r3
 8020816:	2b00      	cmp	r3, #0
 8020818:	d12d      	bne.n	8020876 <I2C_Slave_ISR_IT+0xbe>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
 802081a:	68fb      	ldr	r3, [r7, #12]
 802081c:	2241      	movs	r2, #65	; 0x41
 802081e:	5c9b      	ldrb	r3, [r3, r2]
 8020820:	b2db      	uxtb	r3, r3
 8020822:	2b28      	cmp	r3, #40	; 0x28
 8020824:	d10b      	bne.n	802083e <I2C_Slave_ISR_IT+0x86>
 8020826:	697a      	ldr	r2, [r7, #20]
 8020828:	2380      	movs	r3, #128	; 0x80
 802082a:	049b      	lsls	r3, r3, #18
 802082c:	429a      	cmp	r2, r3
 802082e:	d106      	bne.n	802083e <I2C_Slave_ISR_IT+0x86>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
 8020830:	693a      	ldr	r2, [r7, #16]
 8020832:	68fb      	ldr	r3, [r7, #12]
 8020834:	0011      	movs	r1, r2
 8020836:	0018      	movs	r0, r3
 8020838:	f000 faee 	bl	8020e18 <I2C_ITListenCplt>
 802083c:	e036      	b.n	80208ac <I2C_Slave_ISR_IT+0xf4>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 802083e:	68fb      	ldr	r3, [r7, #12]
 8020840:	2241      	movs	r2, #65	; 0x41
 8020842:	5c9b      	ldrb	r3, [r3, r2]
 8020844:	b2db      	uxtb	r3, r3
 8020846:	2b29      	cmp	r3, #41	; 0x29
 8020848:	d110      	bne.n	802086c <I2C_Slave_ISR_IT+0xb4>
 802084a:	697b      	ldr	r3, [r7, #20]
 802084c:	4a59      	ldr	r2, [pc, #356]	; (80209b4 <I2C_Slave_ISR_IT+0x1fc>)
 802084e:	4293      	cmp	r3, r2
 8020850:	d00c      	beq.n	802086c <I2C_Slave_ISR_IT+0xb4>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8020852:	68fb      	ldr	r3, [r7, #12]
 8020854:	681b      	ldr	r3, [r3, #0]
 8020856:	2210      	movs	r2, #16
 8020858:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
 802085a:	68fb      	ldr	r3, [r7, #12]
 802085c:	0018      	movs	r0, r3
 802085e:	f000 fc40 	bl	80210e2 <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
 8020862:	68fb      	ldr	r3, [r7, #12]
 8020864:	0018      	movs	r0, r3
 8020866:	f000 f94f 	bl	8020b08 <I2C_ITSlaveSeqCplt>
 802086a:	e01f      	b.n	80208ac <I2C_Slave_ISR_IT+0xf4>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 802086c:	68fb      	ldr	r3, [r7, #12]
 802086e:	681b      	ldr	r3, [r3, #0]
 8020870:	2210      	movs	r2, #16
 8020872:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
 8020874:	e091      	b.n	802099a <I2C_Slave_ISR_IT+0x1e2>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8020876:	68fb      	ldr	r3, [r7, #12]
 8020878:	681b      	ldr	r3, [r3, #0]
 802087a:	2210      	movs	r2, #16
 802087c:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 802087e:	68fb      	ldr	r3, [r7, #12]
 8020880:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020882:	2204      	movs	r2, #4
 8020884:	431a      	orrs	r2, r3
 8020886:	68fb      	ldr	r3, [r7, #12]
 8020888:	645a      	str	r2, [r3, #68]	; 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 802088a:	697b      	ldr	r3, [r7, #20]
 802088c:	2b00      	cmp	r3, #0
 802088e:	d005      	beq.n	802089c <I2C_Slave_ISR_IT+0xe4>
 8020890:	697a      	ldr	r2, [r7, #20]
 8020892:	2380      	movs	r3, #128	; 0x80
 8020894:	045b      	lsls	r3, r3, #17
 8020896:	429a      	cmp	r2, r3
 8020898:	d000      	beq.n	802089c <I2C_Slave_ISR_IT+0xe4>
 802089a:	e07e      	b.n	802099a <I2C_Slave_ISR_IT+0x1e2>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
 802089c:	68fb      	ldr	r3, [r7, #12]
 802089e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80208a0:	68fb      	ldr	r3, [r7, #12]
 80208a2:	0011      	movs	r1, r2
 80208a4:	0018      	movs	r0, r3
 80208a6:	f000 fb0f 	bl	8020ec8 <I2C_ITError>
    if (hi2c->XferCount == 0U)
 80208aa:	e076      	b.n	802099a <I2C_Slave_ISR_IT+0x1e2>
 80208ac:	e075      	b.n	802099a <I2C_Slave_ISR_IT+0x1e2>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
 80208ae:	693b      	ldr	r3, [r7, #16]
 80208b0:	2204      	movs	r2, #4
 80208b2:	4013      	ands	r3, r2
 80208b4:	d02f      	beq.n	8020916 <I2C_Slave_ISR_IT+0x15e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 80208b6:	687b      	ldr	r3, [r7, #4]
 80208b8:	2204      	movs	r2, #4
 80208ba:	4013      	ands	r3, r2
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
 80208bc:	d02b      	beq.n	8020916 <I2C_Slave_ISR_IT+0x15e>
  {
    if (hi2c->XferCount > 0U)
 80208be:	68fb      	ldr	r3, [r7, #12]
 80208c0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80208c2:	b29b      	uxth	r3, r3
 80208c4:	2b00      	cmp	r3, #0
 80208c6:	d018      	beq.n	80208fa <I2C_Slave_ISR_IT+0x142>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 80208c8:	68fb      	ldr	r3, [r7, #12]
 80208ca:	681b      	ldr	r3, [r3, #0]
 80208cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80208ce:	68fb      	ldr	r3, [r7, #12]
 80208d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80208d2:	b2d2      	uxtb	r2, r2
 80208d4:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 80208d6:	68fb      	ldr	r3, [r7, #12]
 80208d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80208da:	1c5a      	adds	r2, r3, #1
 80208dc:	68fb      	ldr	r3, [r7, #12]
 80208de:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
 80208e0:	68fb      	ldr	r3, [r7, #12]
 80208e2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80208e4:	3b01      	subs	r3, #1
 80208e6:	b29a      	uxth	r2, r3
 80208e8:	68fb      	ldr	r3, [r7, #12]
 80208ea:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 80208ec:	68fb      	ldr	r3, [r7, #12]
 80208ee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80208f0:	b29b      	uxth	r3, r3
 80208f2:	3b01      	subs	r3, #1
 80208f4:	b29a      	uxth	r2, r3
 80208f6:	68fb      	ldr	r3, [r7, #12]
 80208f8:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
 80208fa:	68fb      	ldr	r3, [r7, #12]
 80208fc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80208fe:	b29b      	uxth	r3, r3
 8020900:	2b00      	cmp	r3, #0
 8020902:	d14c      	bne.n	802099e <I2C_Slave_ISR_IT+0x1e6>
 8020904:	697b      	ldr	r3, [r7, #20]
 8020906:	4a2b      	ldr	r2, [pc, #172]	; (80209b4 <I2C_Slave_ISR_IT+0x1fc>)
 8020908:	4293      	cmp	r3, r2
 802090a:	d048      	beq.n	802099e <I2C_Slave_ISR_IT+0x1e6>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
 802090c:	68fb      	ldr	r3, [r7, #12]
 802090e:	0018      	movs	r0, r3
 8020910:	f000 f8fa 	bl	8020b08 <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
 8020914:	e043      	b.n	802099e <I2C_Slave_ISR_IT+0x1e6>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
 8020916:	693b      	ldr	r3, [r7, #16]
 8020918:	2208      	movs	r2, #8
 802091a:	4013      	ands	r3, r2
 802091c:	d00a      	beq.n	8020934 <I2C_Slave_ISR_IT+0x17c>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
 802091e:	687b      	ldr	r3, [r7, #4]
 8020920:	2208      	movs	r2, #8
 8020922:	4013      	ands	r3, r2
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
 8020924:	d006      	beq.n	8020934 <I2C_Slave_ISR_IT+0x17c>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
 8020926:	693a      	ldr	r2, [r7, #16]
 8020928:	68fb      	ldr	r3, [r7, #12]
 802092a:	0011      	movs	r1, r2
 802092c:	0018      	movs	r0, r3
 802092e:	f000 f843 	bl	80209b8 <I2C_ITAddrCplt>
 8020932:	e035      	b.n	80209a0 <I2C_Slave_ISR_IT+0x1e8>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
 8020934:	693b      	ldr	r3, [r7, #16]
 8020936:	2202      	movs	r2, #2
 8020938:	4013      	ands	r3, r2
 802093a:	d031      	beq.n	80209a0 <I2C_Slave_ISR_IT+0x1e8>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
 802093c:	687b      	ldr	r3, [r7, #4]
 802093e:	2202      	movs	r2, #2
 8020940:	4013      	ands	r3, r2
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
 8020942:	d02d      	beq.n	80209a0 <I2C_Slave_ISR_IT+0x1e8>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Data have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
 8020944:	68fb      	ldr	r3, [r7, #12]
 8020946:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020948:	b29b      	uxth	r3, r3
 802094a:	2b00      	cmp	r3, #0
 802094c:	d018      	beq.n	8020980 <I2C_Slave_ISR_IT+0x1c8>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 802094e:	68fb      	ldr	r3, [r7, #12]
 8020950:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020952:	781a      	ldrb	r2, [r3, #0]
 8020954:	68fb      	ldr	r3, [r7, #12]
 8020956:	681b      	ldr	r3, [r3, #0]
 8020958:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 802095a:	68fb      	ldr	r3, [r7, #12]
 802095c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802095e:	1c5a      	adds	r2, r3, #1
 8020960:	68fb      	ldr	r3, [r7, #12]
 8020962:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
 8020964:	68fb      	ldr	r3, [r7, #12]
 8020966:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020968:	b29b      	uxth	r3, r3
 802096a:	3b01      	subs	r3, #1
 802096c:	b29a      	uxth	r2, r3
 802096e:	68fb      	ldr	r3, [r7, #12]
 8020970:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
 8020972:	68fb      	ldr	r3, [r7, #12]
 8020974:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020976:	3b01      	subs	r3, #1
 8020978:	b29a      	uxth	r2, r3
 802097a:	68fb      	ldr	r3, [r7, #12]
 802097c:	851a      	strh	r2, [r3, #40]	; 0x28
 802097e:	e00f      	b.n	80209a0 <I2C_Slave_ISR_IT+0x1e8>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
 8020980:	697a      	ldr	r2, [r7, #20]
 8020982:	2380      	movs	r3, #128	; 0x80
 8020984:	045b      	lsls	r3, r3, #17
 8020986:	429a      	cmp	r2, r3
 8020988:	d002      	beq.n	8020990 <I2C_Slave_ISR_IT+0x1d8>
 802098a:	697b      	ldr	r3, [r7, #20]
 802098c:	2b00      	cmp	r3, #0
 802098e:	d107      	bne.n	80209a0 <I2C_Slave_ISR_IT+0x1e8>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
 8020990:	68fb      	ldr	r3, [r7, #12]
 8020992:	0018      	movs	r0, r3
 8020994:	f000 f8b8 	bl	8020b08 <I2C_ITSlaveSeqCplt>
 8020998:	e002      	b.n	80209a0 <I2C_Slave_ISR_IT+0x1e8>
    if (hi2c->XferCount == 0U)
 802099a:	46c0      	nop			; (mov r8, r8)
 802099c:	e000      	b.n	80209a0 <I2C_Slave_ISR_IT+0x1e8>
    if ((hi2c->XferCount == 0U) && \
 802099e:	46c0      	nop			; (mov r8, r8)
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 80209a0:	68fb      	ldr	r3, [r7, #12]
 80209a2:	2240      	movs	r2, #64	; 0x40
 80209a4:	2100      	movs	r1, #0
 80209a6:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 80209a8:	2300      	movs	r3, #0
}
 80209aa:	0018      	movs	r0, r3
 80209ac:	46bd      	mov	sp, r7
 80209ae:	b006      	add	sp, #24
 80209b0:	bd80      	pop	{r7, pc}
 80209b2:	46c0      	nop			; (mov r8, r8)
 80209b4:	ffff0000 	.word	0xffff0000

080209b8 <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
 80209b8:	b5b0      	push	{r4, r5, r7, lr}
 80209ba:	b084      	sub	sp, #16
 80209bc:	af00      	add	r7, sp, #0
 80209be:	6078      	str	r0, [r7, #4]
 80209c0:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 80209c2:	687b      	ldr	r3, [r7, #4]
 80209c4:	2241      	movs	r2, #65	; 0x41
 80209c6:	5c9b      	ldrb	r3, [r3, r2]
 80209c8:	b2db      	uxtb	r3, r3
 80209ca:	001a      	movs	r2, r3
 80209cc:	2328      	movs	r3, #40	; 0x28
 80209ce:	4013      	ands	r3, r2
 80209d0:	2b28      	cmp	r3, #40	; 0x28
 80209d2:	d000      	beq.n	80209d6 <I2C_ITAddrCplt+0x1e>
 80209d4:	e08b      	b.n	8020aee <I2C_ITAddrCplt+0x136>
  {
    transferdirection = I2C_GET_DIR(hi2c);
 80209d6:	687b      	ldr	r3, [r7, #4]
 80209d8:	681b      	ldr	r3, [r3, #0]
 80209da:	699b      	ldr	r3, [r3, #24]
 80209dc:	0c1b      	lsrs	r3, r3, #16
 80209de:	b2da      	uxtb	r2, r3
 80209e0:	250f      	movs	r5, #15
 80209e2:	197b      	adds	r3, r7, r5
 80209e4:	2101      	movs	r1, #1
 80209e6:	400a      	ands	r2, r1
 80209e8:	701a      	strb	r2, [r3, #0]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80209ea:	687b      	ldr	r3, [r7, #4]
 80209ec:	681b      	ldr	r3, [r3, #0]
 80209ee:	699b      	ldr	r3, [r3, #24]
 80209f0:	0c1b      	lsrs	r3, r3, #16
 80209f2:	b29a      	uxth	r2, r3
 80209f4:	200c      	movs	r0, #12
 80209f6:	183b      	adds	r3, r7, r0
 80209f8:	21fe      	movs	r1, #254	; 0xfe
 80209fa:	400a      	ands	r2, r1
 80209fc:	801a      	strh	r2, [r3, #0]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 80209fe:	687b      	ldr	r3, [r7, #4]
 8020a00:	681b      	ldr	r3, [r3, #0]
 8020a02:	689b      	ldr	r3, [r3, #8]
 8020a04:	b29a      	uxth	r2, r3
 8020a06:	240a      	movs	r4, #10
 8020a08:	193b      	adds	r3, r7, r4
 8020a0a:	0592      	lsls	r2, r2, #22
 8020a0c:	0d92      	lsrs	r2, r2, #22
 8020a0e:	801a      	strh	r2, [r3, #0]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
 8020a10:	687b      	ldr	r3, [r7, #4]
 8020a12:	681b      	ldr	r3, [r3, #0]
 8020a14:	68db      	ldr	r3, [r3, #12]
 8020a16:	b29a      	uxth	r2, r3
 8020a18:	2308      	movs	r3, #8
 8020a1a:	18fb      	adds	r3, r7, r3
 8020a1c:	21fe      	movs	r1, #254	; 0xfe
 8020a1e:	400a      	ands	r2, r1
 8020a20:	801a      	strh	r2, [r3, #0]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8020a22:	687b      	ldr	r3, [r7, #4]
 8020a24:	68db      	ldr	r3, [r3, #12]
 8020a26:	2b02      	cmp	r3, #2
 8020a28:	d14a      	bne.n	8020ac0 <I2C_ITAddrCplt+0x108>
    {
      if ((slaveaddrcode & SLAVE_ADDR_MSK) == ((ownadd1code >> SLAVE_ADDR_SHIFT) & SLAVE_ADDR_MSK))
 8020a2a:	0021      	movs	r1, r4
 8020a2c:	187b      	adds	r3, r7, r1
 8020a2e:	881b      	ldrh	r3, [r3, #0]
 8020a30:	09db      	lsrs	r3, r3, #7
 8020a32:	b29a      	uxth	r2, r3
 8020a34:	183b      	adds	r3, r7, r0
 8020a36:	881b      	ldrh	r3, [r3, #0]
 8020a38:	4053      	eors	r3, r2
 8020a3a:	b29b      	uxth	r3, r3
 8020a3c:	001a      	movs	r2, r3
 8020a3e:	2306      	movs	r3, #6
 8020a40:	4013      	ands	r3, r2
 8020a42:	d121      	bne.n	8020a88 <I2C_ITAddrCplt+0xd0>
      {
        slaveaddrcode = ownadd1code;
 8020a44:	183b      	adds	r3, r7, r0
 8020a46:	187a      	adds	r2, r7, r1
 8020a48:	8812      	ldrh	r2, [r2, #0]
 8020a4a:	801a      	strh	r2, [r3, #0]
        hi2c->AddrEventCount++;
 8020a4c:	687b      	ldr	r3, [r7, #4]
 8020a4e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8020a50:	1c5a      	adds	r2, r3, #1
 8020a52:	687b      	ldr	r3, [r7, #4]
 8020a54:	649a      	str	r2, [r3, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
 8020a56:	687b      	ldr	r3, [r7, #4]
 8020a58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8020a5a:	2b02      	cmp	r3, #2
 8020a5c:	d14f      	bne.n	8020afe <I2C_ITAddrCplt+0x146>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
 8020a5e:	687b      	ldr	r3, [r7, #4]
 8020a60:	2200      	movs	r2, #0
 8020a62:	649a      	str	r2, [r3, #72]	; 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8020a64:	687b      	ldr	r3, [r7, #4]
 8020a66:	681b      	ldr	r3, [r3, #0]
 8020a68:	2208      	movs	r2, #8
 8020a6a:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8020a6c:	687b      	ldr	r3, [r7, #4]
 8020a6e:	2240      	movs	r2, #64	; 0x40
 8020a70:	2100      	movs	r1, #0
 8020a72:	5499      	strb	r1, [r3, r2]

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8020a74:	687b      	ldr	r3, [r7, #4]
 8020a76:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8020a78:	183a      	adds	r2, r7, r0
 8020a7a:	8814      	ldrh	r4, [r2, #0]
 8020a7c:	197a      	adds	r2, r7, r5
 8020a7e:	7811      	ldrb	r1, [r2, #0]
 8020a80:	6878      	ldr	r0, [r7, #4]
 8020a82:	0022      	movs	r2, r4
 8020a84:	4798      	blx	r3
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
 8020a86:	e03a      	b.n	8020afe <I2C_ITAddrCplt+0x146>
        slaveaddrcode = ownadd2code;
 8020a88:	240c      	movs	r4, #12
 8020a8a:	193b      	adds	r3, r7, r4
 8020a8c:	2208      	movs	r2, #8
 8020a8e:	18ba      	adds	r2, r7, r2
 8020a90:	8812      	ldrh	r2, [r2, #0]
 8020a92:	801a      	strh	r2, [r3, #0]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
 8020a94:	2380      	movs	r3, #128	; 0x80
 8020a96:	021a      	lsls	r2, r3, #8
 8020a98:	687b      	ldr	r3, [r7, #4]
 8020a9a:	0011      	movs	r1, r2
 8020a9c:	0018      	movs	r0, r3
 8020a9e:	f000 fb61 	bl	8021164 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
 8020aa2:	687b      	ldr	r3, [r7, #4]
 8020aa4:	2240      	movs	r2, #64	; 0x40
 8020aa6:	2100      	movs	r1, #0
 8020aa8:	5499      	strb	r1, [r3, r2]
        hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8020aaa:	687b      	ldr	r3, [r7, #4]
 8020aac:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8020aae:	193a      	adds	r2, r7, r4
 8020ab0:	8814      	ldrh	r4, [r2, #0]
 8020ab2:	220f      	movs	r2, #15
 8020ab4:	18ba      	adds	r2, r7, r2
 8020ab6:	7811      	ldrb	r1, [r2, #0]
 8020ab8:	6878      	ldr	r0, [r7, #4]
 8020aba:	0022      	movs	r2, r4
 8020abc:	4798      	blx	r3
}
 8020abe:	e01e      	b.n	8020afe <I2C_ITAddrCplt+0x146>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
 8020ac0:	2380      	movs	r3, #128	; 0x80
 8020ac2:	021a      	lsls	r2, r3, #8
 8020ac4:	687b      	ldr	r3, [r7, #4]
 8020ac6:	0011      	movs	r1, r2
 8020ac8:	0018      	movs	r0, r3
 8020aca:	f000 fb4b 	bl	8021164 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
 8020ace:	687b      	ldr	r3, [r7, #4]
 8020ad0:	2240      	movs	r2, #64	; 0x40
 8020ad2:	2100      	movs	r1, #0
 8020ad4:	5499      	strb	r1, [r3, r2]
      hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8020ad6:	687b      	ldr	r3, [r7, #4]
 8020ad8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8020ada:	220c      	movs	r2, #12
 8020adc:	18ba      	adds	r2, r7, r2
 8020ade:	8814      	ldrh	r4, [r2, #0]
 8020ae0:	220f      	movs	r2, #15
 8020ae2:	18ba      	adds	r2, r7, r2
 8020ae4:	7811      	ldrb	r1, [r2, #0]
 8020ae6:	6878      	ldr	r0, [r7, #4]
 8020ae8:	0022      	movs	r2, r4
 8020aea:	4798      	blx	r3
}
 8020aec:	e007      	b.n	8020afe <I2C_ITAddrCplt+0x146>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8020aee:	687b      	ldr	r3, [r7, #4]
 8020af0:	681b      	ldr	r3, [r3, #0]
 8020af2:	2208      	movs	r2, #8
 8020af4:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
 8020af6:	687b      	ldr	r3, [r7, #4]
 8020af8:	2240      	movs	r2, #64	; 0x40
 8020afa:	2100      	movs	r1, #0
 8020afc:	5499      	strb	r1, [r3, r2]
}
 8020afe:	46c0      	nop			; (mov r8, r8)
 8020b00:	46bd      	mov	sp, r7
 8020b02:	b004      	add	sp, #16
 8020b04:	bdb0      	pop	{r4, r5, r7, pc}
	...

08020b08 <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
 8020b08:	b580      	push	{r7, lr}
 8020b0a:	b084      	sub	sp, #16
 8020b0c:	af00      	add	r7, sp, #0
 8020b0e:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 8020b10:	687b      	ldr	r3, [r7, #4]
 8020b12:	681b      	ldr	r3, [r3, #0]
 8020b14:	681b      	ldr	r3, [r3, #0]
 8020b16:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8020b18:	687b      	ldr	r3, [r7, #4]
 8020b1a:	2242      	movs	r2, #66	; 0x42
 8020b1c:	2100      	movs	r1, #0
 8020b1e:	5499      	strb	r1, [r3, r2]

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 8020b20:	68fa      	ldr	r2, [r7, #12]
 8020b22:	2380      	movs	r3, #128	; 0x80
 8020b24:	01db      	lsls	r3, r3, #7
 8020b26:	4013      	ands	r3, r2
 8020b28:	d008      	beq.n	8020b3c <I2C_ITSlaveSeqCplt+0x34>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8020b2a:	687b      	ldr	r3, [r7, #4]
 8020b2c:	681b      	ldr	r3, [r3, #0]
 8020b2e:	681a      	ldr	r2, [r3, #0]
 8020b30:	687b      	ldr	r3, [r7, #4]
 8020b32:	681b      	ldr	r3, [r3, #0]
 8020b34:	4925      	ldr	r1, [pc, #148]	; (8020bcc <I2C_ITSlaveSeqCplt+0xc4>)
 8020b36:	400a      	ands	r2, r1
 8020b38:	601a      	str	r2, [r3, #0]
 8020b3a:	e00c      	b.n	8020b56 <I2C_ITSlaveSeqCplt+0x4e>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 8020b3c:	68fa      	ldr	r2, [r7, #12]
 8020b3e:	2380      	movs	r3, #128	; 0x80
 8020b40:	021b      	lsls	r3, r3, #8
 8020b42:	4013      	ands	r3, r2
 8020b44:	d007      	beq.n	8020b56 <I2C_ITSlaveSeqCplt+0x4e>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8020b46:	687b      	ldr	r3, [r7, #4]
 8020b48:	681b      	ldr	r3, [r3, #0]
 8020b4a:	681a      	ldr	r2, [r3, #0]
 8020b4c:	687b      	ldr	r3, [r7, #4]
 8020b4e:	681b      	ldr	r3, [r3, #0]
 8020b50:	491f      	ldr	r1, [pc, #124]	; (8020bd0 <I2C_ITSlaveSeqCplt+0xc8>)
 8020b52:	400a      	ands	r2, r1
 8020b54:	601a      	str	r2, [r3, #0]
  else
  {
    /* Do nothing */
  }

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8020b56:	687b      	ldr	r3, [r7, #4]
 8020b58:	2241      	movs	r2, #65	; 0x41
 8020b5a:	5c9b      	ldrb	r3, [r3, r2]
 8020b5c:	b2db      	uxtb	r3, r3
 8020b5e:	2b29      	cmp	r3, #41	; 0x29
 8020b60:	d115      	bne.n	8020b8e <I2C_ITSlaveSeqCplt+0x86>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8020b62:	687b      	ldr	r3, [r7, #4]
 8020b64:	2241      	movs	r2, #65	; 0x41
 8020b66:	2128      	movs	r1, #40	; 0x28
 8020b68:	5499      	strb	r1, [r3, r2]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8020b6a:	687b      	ldr	r3, [r7, #4]
 8020b6c:	2221      	movs	r2, #33	; 0x21
 8020b6e:	631a      	str	r2, [r3, #48]	; 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
 8020b70:	687b      	ldr	r3, [r7, #4]
 8020b72:	2101      	movs	r1, #1
 8020b74:	0018      	movs	r0, r3
 8020b76:	f000 faf5 	bl	8021164 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8020b7a:	687b      	ldr	r3, [r7, #4]
 8020b7c:	2240      	movs	r2, #64	; 0x40
 8020b7e:	2100      	movs	r1, #0
 8020b80:	5499      	strb	r1, [r3, r2]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
 8020b82:	687b      	ldr	r3, [r7, #4]
 8020b84:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8020b86:	687a      	ldr	r2, [r7, #4]
 8020b88:	0010      	movs	r0, r2
 8020b8a:	4798      	blx	r3
  }
  else
  {
    /* Nothing to do */
  }
}
 8020b8c:	e01a      	b.n	8020bc4 <I2C_ITSlaveSeqCplt+0xbc>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
 8020b8e:	687b      	ldr	r3, [r7, #4]
 8020b90:	2241      	movs	r2, #65	; 0x41
 8020b92:	5c9b      	ldrb	r3, [r3, r2]
 8020b94:	b2db      	uxtb	r3, r3
 8020b96:	2b2a      	cmp	r3, #42	; 0x2a
 8020b98:	d114      	bne.n	8020bc4 <I2C_ITSlaveSeqCplt+0xbc>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8020b9a:	687b      	ldr	r3, [r7, #4]
 8020b9c:	2241      	movs	r2, #65	; 0x41
 8020b9e:	2128      	movs	r1, #40	; 0x28
 8020ba0:	5499      	strb	r1, [r3, r2]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8020ba2:	687b      	ldr	r3, [r7, #4]
 8020ba4:	2222      	movs	r2, #34	; 0x22
 8020ba6:	631a      	str	r2, [r3, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
 8020ba8:	687b      	ldr	r3, [r7, #4]
 8020baa:	2102      	movs	r1, #2
 8020bac:	0018      	movs	r0, r3
 8020bae:	f000 fad9 	bl	8021164 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
 8020bb2:	687b      	ldr	r3, [r7, #4]
 8020bb4:	2240      	movs	r2, #64	; 0x40
 8020bb6:	2100      	movs	r1, #0
 8020bb8:	5499      	strb	r1, [r3, r2]
    hi2c->SlaveRxCpltCallback(hi2c);
 8020bba:	687b      	ldr	r3, [r7, #4]
 8020bbc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8020bbe:	687a      	ldr	r2, [r7, #4]
 8020bc0:	0010      	movs	r0, r2
 8020bc2:	4798      	blx	r3
}
 8020bc4:	46c0      	nop			; (mov r8, r8)
 8020bc6:	46bd      	mov	sp, r7
 8020bc8:	b004      	add	sp, #16
 8020bca:	bd80      	pop	{r7, pc}
 8020bcc:	ffffbfff 	.word	0xffffbfff
 8020bd0:	ffff7fff 	.word	0xffff7fff

08020bd4 <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
 8020bd4:	b580      	push	{r7, lr}
 8020bd6:	b086      	sub	sp, #24
 8020bd8:	af00      	add	r7, sp, #0
 8020bda:	6078      	str	r0, [r7, #4]
 8020bdc:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 8020bde:	687b      	ldr	r3, [r7, #4]
 8020be0:	681b      	ldr	r3, [r3, #0]
 8020be2:	681b      	ldr	r3, [r3, #0]
 8020be4:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
 8020be6:	683b      	ldr	r3, [r7, #0]
 8020be8:	617b      	str	r3, [r7, #20]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8020bea:	200f      	movs	r0, #15
 8020bec:	183b      	adds	r3, r7, r0
 8020bee:	687a      	ldr	r2, [r7, #4]
 8020bf0:	2141      	movs	r1, #65	; 0x41
 8020bf2:	5c52      	ldrb	r2, [r2, r1]
 8020bf4:	701a      	strb	r2, [r3, #0]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8020bf6:	687b      	ldr	r3, [r7, #4]
 8020bf8:	681b      	ldr	r3, [r3, #0]
 8020bfa:	2220      	movs	r2, #32
 8020bfc:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8020bfe:	183b      	adds	r3, r7, r0
 8020c00:	781b      	ldrb	r3, [r3, #0]
 8020c02:	2b21      	cmp	r3, #33	; 0x21
 8020c04:	d003      	beq.n	8020c0e <I2C_ITSlaveCplt+0x3a>
 8020c06:	183b      	adds	r3, r7, r0
 8020c08:	781b      	ldrb	r3, [r3, #0]
 8020c0a:	2b29      	cmp	r3, #41	; 0x29
 8020c0c:	d109      	bne.n	8020c22 <I2C_ITSlaveCplt+0x4e>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
 8020c0e:	4a7c      	ldr	r2, [pc, #496]	; (8020e00 <I2C_ITSlaveCplt+0x22c>)
 8020c10:	687b      	ldr	r3, [r7, #4]
 8020c12:	0011      	movs	r1, r2
 8020c14:	0018      	movs	r0, r3
 8020c16:	f000 faa5 	bl	8021164 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8020c1a:	687b      	ldr	r3, [r7, #4]
 8020c1c:	2221      	movs	r2, #33	; 0x21
 8020c1e:	631a      	str	r2, [r3, #48]	; 0x30
 8020c20:	e011      	b.n	8020c46 <I2C_ITSlaveCplt+0x72>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8020c22:	220f      	movs	r2, #15
 8020c24:	18bb      	adds	r3, r7, r2
 8020c26:	781b      	ldrb	r3, [r3, #0]
 8020c28:	2b22      	cmp	r3, #34	; 0x22
 8020c2a:	d003      	beq.n	8020c34 <I2C_ITSlaveCplt+0x60>
 8020c2c:	18bb      	adds	r3, r7, r2
 8020c2e:	781b      	ldrb	r3, [r3, #0]
 8020c30:	2b2a      	cmp	r3, #42	; 0x2a
 8020c32:	d108      	bne.n	8020c46 <I2C_ITSlaveCplt+0x72>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
 8020c34:	4a73      	ldr	r2, [pc, #460]	; (8020e04 <I2C_ITSlaveCplt+0x230>)
 8020c36:	687b      	ldr	r3, [r7, #4]
 8020c38:	0011      	movs	r1, r2
 8020c3a:	0018      	movs	r0, r3
 8020c3c:	f000 fa92 	bl	8021164 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8020c40:	687b      	ldr	r3, [r7, #4]
 8020c42:	2222      	movs	r2, #34	; 0x22
 8020c44:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8020c46:	687b      	ldr	r3, [r7, #4]
 8020c48:	681b      	ldr	r3, [r3, #0]
 8020c4a:	685a      	ldr	r2, [r3, #4]
 8020c4c:	687b      	ldr	r3, [r7, #4]
 8020c4e:	681b      	ldr	r3, [r3, #0]
 8020c50:	2180      	movs	r1, #128	; 0x80
 8020c52:	0209      	lsls	r1, r1, #8
 8020c54:	430a      	orrs	r2, r1
 8020c56:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
 8020c58:	687b      	ldr	r3, [r7, #4]
 8020c5a:	681b      	ldr	r3, [r3, #0]
 8020c5c:	685a      	ldr	r2, [r3, #4]
 8020c5e:	687b      	ldr	r3, [r7, #4]
 8020c60:	681b      	ldr	r3, [r3, #0]
 8020c62:	4969      	ldr	r1, [pc, #420]	; (8020e08 <I2C_ITSlaveCplt+0x234>)
 8020c64:	400a      	ands	r2, r1
 8020c66:	605a      	str	r2, [r3, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
 8020c68:	687b      	ldr	r3, [r7, #4]
 8020c6a:	0018      	movs	r0, r3
 8020c6c:	f000 fa39 	bl	80210e2 <I2C_Flush_TXDR>

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 8020c70:	693a      	ldr	r2, [r7, #16]
 8020c72:	2380      	movs	r3, #128	; 0x80
 8020c74:	01db      	lsls	r3, r3, #7
 8020c76:	4013      	ands	r3, r2
 8020c78:	d013      	beq.n	8020ca2 <I2C_ITSlaveCplt+0xce>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8020c7a:	687b      	ldr	r3, [r7, #4]
 8020c7c:	681b      	ldr	r3, [r3, #0]
 8020c7e:	681a      	ldr	r2, [r3, #0]
 8020c80:	687b      	ldr	r3, [r7, #4]
 8020c82:	681b      	ldr	r3, [r3, #0]
 8020c84:	4961      	ldr	r1, [pc, #388]	; (8020e0c <I2C_ITSlaveCplt+0x238>)
 8020c86:	400a      	ands	r2, r1
 8020c88:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
 8020c8a:	687b      	ldr	r3, [r7, #4]
 8020c8c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020c8e:	2b00      	cmp	r3, #0
 8020c90:	d01f      	beq.n	8020cd2 <I2C_ITSlaveCplt+0xfe>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx);
 8020c92:	687b      	ldr	r3, [r7, #4]
 8020c94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020c96:	681b      	ldr	r3, [r3, #0]
 8020c98:	685b      	ldr	r3, [r3, #4]
 8020c9a:	b29a      	uxth	r2, r3
 8020c9c:	687b      	ldr	r3, [r7, #4]
 8020c9e:	855a      	strh	r2, [r3, #42]	; 0x2a
 8020ca0:	e017      	b.n	8020cd2 <I2C_ITSlaveCplt+0xfe>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 8020ca2:	693a      	ldr	r2, [r7, #16]
 8020ca4:	2380      	movs	r3, #128	; 0x80
 8020ca6:	021b      	lsls	r3, r3, #8
 8020ca8:	4013      	ands	r3, r2
 8020caa:	d012      	beq.n	8020cd2 <I2C_ITSlaveCplt+0xfe>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8020cac:	687b      	ldr	r3, [r7, #4]
 8020cae:	681b      	ldr	r3, [r3, #0]
 8020cb0:	681a      	ldr	r2, [r3, #0]
 8020cb2:	687b      	ldr	r3, [r7, #4]
 8020cb4:	681b      	ldr	r3, [r3, #0]
 8020cb6:	4956      	ldr	r1, [pc, #344]	; (8020e10 <I2C_ITSlaveCplt+0x23c>)
 8020cb8:	400a      	ands	r2, r1
 8020cba:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
 8020cbc:	687b      	ldr	r3, [r7, #4]
 8020cbe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020cc0:	2b00      	cmp	r3, #0
 8020cc2:	d006      	beq.n	8020cd2 <I2C_ITSlaveCplt+0xfe>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx);
 8020cc4:	687b      	ldr	r3, [r7, #4]
 8020cc6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020cc8:	681b      	ldr	r3, [r3, #0]
 8020cca:	685b      	ldr	r3, [r3, #4]
 8020ccc:	b29a      	uxth	r2, r3
 8020cce:	687b      	ldr	r3, [r7, #4]
 8020cd0:	855a      	strh	r2, [r3, #42]	; 0x2a
  {
    /* Do nothing */
  }

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
 8020cd2:	697b      	ldr	r3, [r7, #20]
 8020cd4:	2204      	movs	r2, #4
 8020cd6:	4013      	ands	r3, r2
 8020cd8:	d020      	beq.n	8020d1c <I2C_ITSlaveCplt+0x148>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
 8020cda:	697b      	ldr	r3, [r7, #20]
 8020cdc:	2204      	movs	r2, #4
 8020cde:	4393      	bics	r3, r2
 8020ce0:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8020ce2:	687b      	ldr	r3, [r7, #4]
 8020ce4:	681b      	ldr	r3, [r3, #0]
 8020ce6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8020ce8:	687b      	ldr	r3, [r7, #4]
 8020cea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020cec:	b2d2      	uxtb	r2, r2
 8020cee:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8020cf0:	687b      	ldr	r3, [r7, #4]
 8020cf2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020cf4:	1c5a      	adds	r2, r3, #1
 8020cf6:	687b      	ldr	r3, [r7, #4]
 8020cf8:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
 8020cfa:	687b      	ldr	r3, [r7, #4]
 8020cfc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020cfe:	2b00      	cmp	r3, #0
 8020d00:	d00c      	beq.n	8020d1c <I2C_ITSlaveCplt+0x148>
    {
      hi2c->XferSize--;
 8020d02:	687b      	ldr	r3, [r7, #4]
 8020d04:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020d06:	3b01      	subs	r3, #1
 8020d08:	b29a      	uxth	r2, r3
 8020d0a:	687b      	ldr	r3, [r7, #4]
 8020d0c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 8020d0e:	687b      	ldr	r3, [r7, #4]
 8020d10:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020d12:	b29b      	uxth	r3, r3
 8020d14:	3b01      	subs	r3, #1
 8020d16:	b29a      	uxth	r2, r3
 8020d18:	687b      	ldr	r3, [r7, #4]
 8020d1a:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
 8020d1c:	687b      	ldr	r3, [r7, #4]
 8020d1e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020d20:	b29b      	uxth	r3, r3
 8020d22:	2b00      	cmp	r3, #0
 8020d24:	d005      	beq.n	8020d32 <I2C_ITSlaveCplt+0x15e>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8020d26:	687b      	ldr	r3, [r7, #4]
 8020d28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020d2a:	2204      	movs	r2, #4
 8020d2c:	431a      	orrs	r2, r3
 8020d2e:	687b      	ldr	r3, [r7, #4]
 8020d30:	645a      	str	r2, [r3, #68]	; 0x44
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
 8020d32:	687b      	ldr	r3, [r7, #4]
 8020d34:	2242      	movs	r2, #66	; 0x42
 8020d36:	2100      	movs	r1, #0
 8020d38:	5499      	strb	r1, [r3, r2]
  hi2c->XferISR = NULL;
 8020d3a:	687b      	ldr	r3, [r7, #4]
 8020d3c:	2200      	movs	r2, #0
 8020d3e:	635a      	str	r2, [r3, #52]	; 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8020d40:	687b      	ldr	r3, [r7, #4]
 8020d42:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020d44:	2b00      	cmp	r3, #0
 8020d46:	d013      	beq.n	8020d70 <I2C_ITSlaveCplt+0x19c>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
 8020d48:	687b      	ldr	r3, [r7, #4]
 8020d4a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8020d4c:	687b      	ldr	r3, [r7, #4]
 8020d4e:	0011      	movs	r1, r2
 8020d50:	0018      	movs	r0, r3
 8020d52:	f000 f8b9 	bl	8020ec8 <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 8020d56:	687b      	ldr	r3, [r7, #4]
 8020d58:	2241      	movs	r2, #65	; 0x41
 8020d5a:	5c9b      	ldrb	r3, [r3, r2]
 8020d5c:	b2db      	uxtb	r3, r3
 8020d5e:	2b28      	cmp	r3, #40	; 0x28
 8020d60:	d14a      	bne.n	8020df8 <I2C_ITSlaveCplt+0x224>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
 8020d62:	697a      	ldr	r2, [r7, #20]
 8020d64:	687b      	ldr	r3, [r7, #4]
 8020d66:	0011      	movs	r1, r2
 8020d68:	0018      	movs	r0, r3
 8020d6a:	f000 f855 	bl	8020e18 <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 8020d6e:	e043      	b.n	8020df8 <I2C_ITSlaveCplt+0x224>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8020d70:	687b      	ldr	r3, [r7, #4]
 8020d72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8020d74:	4a27      	ldr	r2, [pc, #156]	; (8020e14 <I2C_ITSlaveCplt+0x240>)
 8020d76:	4293      	cmp	r3, r2
 8020d78:	d017      	beq.n	8020daa <I2C_ITSlaveCplt+0x1d6>
    I2C_ITSlaveSeqCplt(hi2c);
 8020d7a:	687b      	ldr	r3, [r7, #4]
 8020d7c:	0018      	movs	r0, r3
 8020d7e:	f7ff fec3 	bl	8020b08 <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8020d82:	687b      	ldr	r3, [r7, #4]
 8020d84:	4a23      	ldr	r2, [pc, #140]	; (8020e14 <I2C_ITSlaveCplt+0x240>)
 8020d86:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
 8020d88:	687b      	ldr	r3, [r7, #4]
 8020d8a:	2241      	movs	r2, #65	; 0x41
 8020d8c:	2120      	movs	r1, #32
 8020d8e:	5499      	strb	r1, [r3, r2]
    hi2c->PreviousState = I2C_STATE_NONE;
 8020d90:	687b      	ldr	r3, [r7, #4]
 8020d92:	2200      	movs	r2, #0
 8020d94:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8020d96:	687b      	ldr	r3, [r7, #4]
 8020d98:	2240      	movs	r2, #64	; 0x40
 8020d9a:	2100      	movs	r1, #0
 8020d9c:	5499      	strb	r1, [r3, r2]
    hi2c->ListenCpltCallback(hi2c);
 8020d9e:	687b      	ldr	r3, [r7, #4]
 8020da0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8020da2:	687a      	ldr	r2, [r7, #4]
 8020da4:	0010      	movs	r0, r2
 8020da6:	4798      	blx	r3
}
 8020da8:	e026      	b.n	8020df8 <I2C_ITSlaveCplt+0x224>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8020daa:	687b      	ldr	r3, [r7, #4]
 8020dac:	2241      	movs	r2, #65	; 0x41
 8020dae:	5c9b      	ldrb	r3, [r3, r2]
 8020db0:	b2db      	uxtb	r3, r3
 8020db2:	2b22      	cmp	r3, #34	; 0x22
 8020db4:	d110      	bne.n	8020dd8 <I2C_ITSlaveCplt+0x204>
    hi2c->State = HAL_I2C_STATE_READY;
 8020db6:	687b      	ldr	r3, [r7, #4]
 8020db8:	2241      	movs	r2, #65	; 0x41
 8020dba:	2120      	movs	r1, #32
 8020dbc:	5499      	strb	r1, [r3, r2]
    hi2c->PreviousState = I2C_STATE_NONE;
 8020dbe:	687b      	ldr	r3, [r7, #4]
 8020dc0:	2200      	movs	r2, #0
 8020dc2:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8020dc4:	687b      	ldr	r3, [r7, #4]
 8020dc6:	2240      	movs	r2, #64	; 0x40
 8020dc8:	2100      	movs	r1, #0
 8020dca:	5499      	strb	r1, [r3, r2]
    hi2c->SlaveRxCpltCallback(hi2c);
 8020dcc:	687b      	ldr	r3, [r7, #4]
 8020dce:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8020dd0:	687a      	ldr	r2, [r7, #4]
 8020dd2:	0010      	movs	r0, r2
 8020dd4:	4798      	blx	r3
}
 8020dd6:	e00f      	b.n	8020df8 <I2C_ITSlaveCplt+0x224>
    hi2c->State = HAL_I2C_STATE_READY;
 8020dd8:	687b      	ldr	r3, [r7, #4]
 8020dda:	2241      	movs	r2, #65	; 0x41
 8020ddc:	2120      	movs	r1, #32
 8020dde:	5499      	strb	r1, [r3, r2]
    hi2c->PreviousState = I2C_STATE_NONE;
 8020de0:	687b      	ldr	r3, [r7, #4]
 8020de2:	2200      	movs	r2, #0
 8020de4:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8020de6:	687b      	ldr	r3, [r7, #4]
 8020de8:	2240      	movs	r2, #64	; 0x40
 8020dea:	2100      	movs	r1, #0
 8020dec:	5499      	strb	r1, [r3, r2]
    hi2c->SlaveTxCpltCallback(hi2c);
 8020dee:	687b      	ldr	r3, [r7, #4]
 8020df0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8020df2:	687a      	ldr	r2, [r7, #4]
 8020df4:	0010      	movs	r0, r2
 8020df6:	4798      	blx	r3
}
 8020df8:	46c0      	nop			; (mov r8, r8)
 8020dfa:	46bd      	mov	sp, r7
 8020dfc:	b006      	add	sp, #24
 8020dfe:	bd80      	pop	{r7, pc}
 8020e00:	00008001 	.word	0x00008001
 8020e04:	00008002 	.word	0x00008002
 8020e08:	fe00e800 	.word	0xfe00e800
 8020e0c:	ffffbfff 	.word	0xffffbfff
 8020e10:	ffff7fff 	.word	0xffff7fff
 8020e14:	ffff0000 	.word	0xffff0000

08020e18 <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
 8020e18:	b580      	push	{r7, lr}
 8020e1a:	b082      	sub	sp, #8
 8020e1c:	af00      	add	r7, sp, #0
 8020e1e:	6078      	str	r0, [r7, #4]
 8020e20:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8020e22:	687b      	ldr	r3, [r7, #4]
 8020e24:	4a26      	ldr	r2, [pc, #152]	; (8020ec0 <I2C_ITListenCplt+0xa8>)
 8020e26:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
 8020e28:	687b      	ldr	r3, [r7, #4]
 8020e2a:	2200      	movs	r2, #0
 8020e2c:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
 8020e2e:	687b      	ldr	r3, [r7, #4]
 8020e30:	2241      	movs	r2, #65	; 0x41
 8020e32:	2120      	movs	r1, #32
 8020e34:	5499      	strb	r1, [r3, r2]
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8020e36:	687b      	ldr	r3, [r7, #4]
 8020e38:	2242      	movs	r2, #66	; 0x42
 8020e3a:	2100      	movs	r1, #0
 8020e3c:	5499      	strb	r1, [r3, r2]
  hi2c->XferISR = NULL;
 8020e3e:	687b      	ldr	r3, [r7, #4]
 8020e40:	2200      	movs	r2, #0
 8020e42:	635a      	str	r2, [r3, #52]	; 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8020e44:	683b      	ldr	r3, [r7, #0]
 8020e46:	2204      	movs	r2, #4
 8020e48:	4013      	ands	r3, r2
 8020e4a:	d022      	beq.n	8020e92 <I2C_ITListenCplt+0x7a>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8020e4c:	687b      	ldr	r3, [r7, #4]
 8020e4e:	681b      	ldr	r3, [r3, #0]
 8020e50:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8020e52:	687b      	ldr	r3, [r7, #4]
 8020e54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020e56:	b2d2      	uxtb	r2, r2
 8020e58:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8020e5a:	687b      	ldr	r3, [r7, #4]
 8020e5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020e5e:	1c5a      	adds	r2, r3, #1
 8020e60:	687b      	ldr	r3, [r7, #4]
 8020e62:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
 8020e64:	687b      	ldr	r3, [r7, #4]
 8020e66:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020e68:	2b00      	cmp	r3, #0
 8020e6a:	d012      	beq.n	8020e92 <I2C_ITListenCplt+0x7a>
    {
      hi2c->XferSize--;
 8020e6c:	687b      	ldr	r3, [r7, #4]
 8020e6e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020e70:	3b01      	subs	r3, #1
 8020e72:	b29a      	uxth	r2, r3
 8020e74:	687b      	ldr	r3, [r7, #4]
 8020e76:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 8020e78:	687b      	ldr	r3, [r7, #4]
 8020e7a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020e7c:	b29b      	uxth	r3, r3
 8020e7e:	3b01      	subs	r3, #1
 8020e80:	b29a      	uxth	r2, r3
 8020e82:	687b      	ldr	r3, [r7, #4]
 8020e84:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8020e86:	687b      	ldr	r3, [r7, #4]
 8020e88:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020e8a:	2204      	movs	r2, #4
 8020e8c:	431a      	orrs	r2, r3
 8020e8e:	687b      	ldr	r3, [r7, #4]
 8020e90:	645a      	str	r2, [r3, #68]	; 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 8020e92:	4a0c      	ldr	r2, [pc, #48]	; (8020ec4 <I2C_ITListenCplt+0xac>)
 8020e94:	687b      	ldr	r3, [r7, #4]
 8020e96:	0011      	movs	r1, r2
 8020e98:	0018      	movs	r0, r3
 8020e9a:	f000 f963 	bl	8021164 <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8020e9e:	687b      	ldr	r3, [r7, #4]
 8020ea0:	681b      	ldr	r3, [r3, #0]
 8020ea2:	2210      	movs	r2, #16
 8020ea4:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 8020ea6:	687b      	ldr	r3, [r7, #4]
 8020ea8:	2240      	movs	r2, #64	; 0x40
 8020eaa:	2100      	movs	r1, #0
 8020eac:	5499      	strb	r1, [r3, r2]

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
 8020eae:	687b      	ldr	r3, [r7, #4]
 8020eb0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8020eb2:	687a      	ldr	r2, [r7, #4]
 8020eb4:	0010      	movs	r0, r2
 8020eb6:	4798      	blx	r3
#else
  HAL_I2C_ListenCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
 8020eb8:	46c0      	nop			; (mov r8, r8)
 8020eba:	46bd      	mov	sp, r7
 8020ebc:	b002      	add	sp, #8
 8020ebe:	bd80      	pop	{r7, pc}
 8020ec0:	ffff0000 	.word	0xffff0000
 8020ec4:	00008003 	.word	0x00008003

08020ec8 <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
 8020ec8:	b580      	push	{r7, lr}
 8020eca:	b084      	sub	sp, #16
 8020ecc:	af00      	add	r7, sp, #0
 8020ece:	6078      	str	r0, [r7, #4]
 8020ed0:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8020ed2:	200f      	movs	r0, #15
 8020ed4:	183b      	adds	r3, r7, r0
 8020ed6:	687a      	ldr	r2, [r7, #4]
 8020ed8:	2141      	movs	r1, #65	; 0x41
 8020eda:	5c52      	ldrb	r2, [r2, r1]
 8020edc:	701a      	strb	r2, [r3, #0]
  uint32_t tmppreviousstate;

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8020ede:	687b      	ldr	r3, [r7, #4]
 8020ee0:	2242      	movs	r2, #66	; 0x42
 8020ee2:	2100      	movs	r1, #0
 8020ee4:	5499      	strb	r1, [r3, r2]
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8020ee6:	687b      	ldr	r3, [r7, #4]
 8020ee8:	4a62      	ldr	r2, [pc, #392]	; (8021074 <I2C_ITError+0x1ac>)
 8020eea:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 8020eec:	687b      	ldr	r3, [r7, #4]
 8020eee:	2200      	movs	r2, #0
 8020ef0:	855a      	strh	r2, [r3, #42]	; 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
 8020ef2:	687b      	ldr	r3, [r7, #4]
 8020ef4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8020ef6:	683b      	ldr	r3, [r7, #0]
 8020ef8:	431a      	orrs	r2, r3
 8020efa:	687b      	ldr	r3, [r7, #4]
 8020efc:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8020efe:	183b      	adds	r3, r7, r0
 8020f00:	781b      	ldrb	r3, [r3, #0]
 8020f02:	2b28      	cmp	r3, #40	; 0x28
 8020f04:	d007      	beq.n	8020f16 <I2C_ITError+0x4e>
 8020f06:	183b      	adds	r3, r7, r0
 8020f08:	781b      	ldrb	r3, [r3, #0]
 8020f0a:	2b29      	cmp	r3, #41	; 0x29
 8020f0c:	d003      	beq.n	8020f16 <I2C_ITError+0x4e>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
 8020f0e:	183b      	adds	r3, r7, r0
 8020f10:	781b      	ldrb	r3, [r3, #0]
 8020f12:	2b2a      	cmp	r3, #42	; 0x2a
 8020f14:	d10c      	bne.n	8020f30 <I2C_ITError+0x68>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 8020f16:	687b      	ldr	r3, [r7, #4]
 8020f18:	2103      	movs	r1, #3
 8020f1a:	0018      	movs	r0, r3
 8020f1c:	f000 f922 	bl	8021164 <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8020f20:	687b      	ldr	r3, [r7, #4]
 8020f22:	2241      	movs	r2, #65	; 0x41
 8020f24:	2128      	movs	r1, #40	; 0x28
 8020f26:	5499      	strb	r1, [r3, r2]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8020f28:	687b      	ldr	r3, [r7, #4]
 8020f2a:	4a53      	ldr	r2, [pc, #332]	; (8021078 <I2C_ITError+0x1b0>)
 8020f2c:	635a      	str	r2, [r3, #52]	; 0x34
 8020f2e:	e012      	b.n	8020f56 <I2C_ITError+0x8e>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 8020f30:	4a52      	ldr	r2, [pc, #328]	; (802107c <I2C_ITError+0x1b4>)
 8020f32:	687b      	ldr	r3, [r7, #4]
 8020f34:	0011      	movs	r1, r2
 8020f36:	0018      	movs	r0, r3
 8020f38:	f000 f914 	bl	8021164 <I2C_Disable_IRQ>

    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8020f3c:	687b      	ldr	r3, [r7, #4]
 8020f3e:	2241      	movs	r2, #65	; 0x41
 8020f40:	5c9b      	ldrb	r3, [r3, r2]
 8020f42:	b2db      	uxtb	r3, r3
 8020f44:	2b60      	cmp	r3, #96	; 0x60
 8020f46:	d003      	beq.n	8020f50 <I2C_ITError+0x88>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
 8020f48:	687b      	ldr	r3, [r7, #4]
 8020f4a:	2241      	movs	r2, #65	; 0x41
 8020f4c:	2120      	movs	r1, #32
 8020f4e:	5499      	strb	r1, [r3, r2]
    }
    hi2c->XferISR       = NULL;
 8020f50:	687b      	ldr	r3, [r7, #4]
 8020f52:	2200      	movs	r2, #0
 8020f54:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
 8020f56:	687b      	ldr	r3, [r7, #4]
 8020f58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020f5a:	60bb      	str	r3, [r7, #8]
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
 8020f5c:	687b      	ldr	r3, [r7, #4]
 8020f5e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020f60:	2b00      	cmp	r3, #0
 8020f62:	d03b      	beq.n	8020fdc <I2C_ITError+0x114>
 8020f64:	68bb      	ldr	r3, [r7, #8]
 8020f66:	2b11      	cmp	r3, #17
 8020f68:	d002      	beq.n	8020f70 <I2C_ITError+0xa8>
 8020f6a:	68bb      	ldr	r3, [r7, #8]
 8020f6c:	2b21      	cmp	r3, #33	; 0x21
 8020f6e:	d135      	bne.n	8020fdc <I2C_ITError+0x114>
                                 (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8020f70:	687b      	ldr	r3, [r7, #4]
 8020f72:	681b      	ldr	r3, [r3, #0]
 8020f74:	681a      	ldr	r2, [r3, #0]
 8020f76:	2380      	movs	r3, #128	; 0x80
 8020f78:	01db      	lsls	r3, r3, #7
 8020f7a:	401a      	ands	r2, r3
 8020f7c:	2380      	movs	r3, #128	; 0x80
 8020f7e:	01db      	lsls	r3, r3, #7
 8020f80:	429a      	cmp	r2, r3
 8020f82:	d107      	bne.n	8020f94 <I2C_ITError+0xcc>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8020f84:	687b      	ldr	r3, [r7, #4]
 8020f86:	681b      	ldr	r3, [r3, #0]
 8020f88:	681a      	ldr	r2, [r3, #0]
 8020f8a:	687b      	ldr	r3, [r7, #4]
 8020f8c:	681b      	ldr	r3, [r3, #0]
 8020f8e:	493c      	ldr	r1, [pc, #240]	; (8021080 <I2C_ITError+0x1b8>)
 8020f90:	400a      	ands	r2, r1
 8020f92:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8020f94:	687b      	ldr	r3, [r7, #4]
 8020f96:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020f98:	0018      	movs	r0, r3
 8020f9a:	f7ff fb8d 	bl	80206b8 <HAL_DMA_GetState>
 8020f9e:	0003      	movs	r3, r0
 8020fa0:	2b01      	cmp	r3, #1
 8020fa2:	d016      	beq.n	8020fd2 <I2C_ITError+0x10a>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8020fa4:	687b      	ldr	r3, [r7, #4]
 8020fa6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020fa8:	4a36      	ldr	r2, [pc, #216]	; (8021084 <I2C_ITError+0x1bc>)
 8020faa:	639a      	str	r2, [r3, #56]	; 0x38

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8020fac:	687b      	ldr	r3, [r7, #4]
 8020fae:	2240      	movs	r2, #64	; 0x40
 8020fb0:	2100      	movs	r1, #0
 8020fb2:	5499      	strb	r1, [r3, r2]

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8020fb4:	687b      	ldr	r3, [r7, #4]
 8020fb6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020fb8:	0018      	movs	r0, r3
 8020fba:	f7ff fb15 	bl	80205e8 <HAL_DMA_Abort_IT>
 8020fbe:	1e03      	subs	r3, r0, #0
 8020fc0:	d051      	beq.n	8021066 <I2C_ITError+0x19e>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8020fc2:	687b      	ldr	r3, [r7, #4]
 8020fc4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020fc6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8020fc8:	687b      	ldr	r3, [r7, #4]
 8020fca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8020fcc:	0018      	movs	r0, r3
 8020fce:	4790      	blx	r2
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8020fd0:	e049      	b.n	8021066 <I2C_ITError+0x19e>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
 8020fd2:	687b      	ldr	r3, [r7, #4]
 8020fd4:	0018      	movs	r0, r3
 8020fd6:	f000 f859 	bl	802108c <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8020fda:	e044      	b.n	8021066 <I2C_ITError+0x19e>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \
 8020fdc:	687b      	ldr	r3, [r7, #4]
 8020fde:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020fe0:	2b00      	cmp	r3, #0
 8020fe2:	d03b      	beq.n	802105c <I2C_ITError+0x194>
 8020fe4:	68bb      	ldr	r3, [r7, #8]
 8020fe6:	2b12      	cmp	r3, #18
 8020fe8:	d002      	beq.n	8020ff0 <I2C_ITError+0x128>
 8020fea:	68bb      	ldr	r3, [r7, #8]
 8020fec:	2b22      	cmp	r3, #34	; 0x22
 8020fee:	d135      	bne.n	802105c <I2C_ITError+0x194>
                                      (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8020ff0:	687b      	ldr	r3, [r7, #4]
 8020ff2:	681b      	ldr	r3, [r3, #0]
 8020ff4:	681a      	ldr	r2, [r3, #0]
 8020ff6:	2380      	movs	r3, #128	; 0x80
 8020ff8:	021b      	lsls	r3, r3, #8
 8020ffa:	401a      	ands	r2, r3
 8020ffc:	2380      	movs	r3, #128	; 0x80
 8020ffe:	021b      	lsls	r3, r3, #8
 8021000:	429a      	cmp	r2, r3
 8021002:	d107      	bne.n	8021014 <I2C_ITError+0x14c>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8021004:	687b      	ldr	r3, [r7, #4]
 8021006:	681b      	ldr	r3, [r3, #0]
 8021008:	681a      	ldr	r2, [r3, #0]
 802100a:	687b      	ldr	r3, [r7, #4]
 802100c:	681b      	ldr	r3, [r3, #0]
 802100e:	491e      	ldr	r1, [pc, #120]	; (8021088 <I2C_ITError+0x1c0>)
 8021010:	400a      	ands	r2, r1
 8021012:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8021014:	687b      	ldr	r3, [r7, #4]
 8021016:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021018:	0018      	movs	r0, r3
 802101a:	f7ff fb4d 	bl	80206b8 <HAL_DMA_GetState>
 802101e:	0003      	movs	r3, r0
 8021020:	2b01      	cmp	r3, #1
 8021022:	d016      	beq.n	8021052 <I2C_ITError+0x18a>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8021024:	687b      	ldr	r3, [r7, #4]
 8021026:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021028:	4a16      	ldr	r2, [pc, #88]	; (8021084 <I2C_ITError+0x1bc>)
 802102a:	639a      	str	r2, [r3, #56]	; 0x38

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 802102c:	687b      	ldr	r3, [r7, #4]
 802102e:	2240      	movs	r2, #64	; 0x40
 8021030:	2100      	movs	r1, #0
 8021032:	5499      	strb	r1, [r3, r2]

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8021034:	687b      	ldr	r3, [r7, #4]
 8021036:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021038:	0018      	movs	r0, r3
 802103a:	f7ff fad5 	bl	80205e8 <HAL_DMA_Abort_IT>
 802103e:	1e03      	subs	r3, r0, #0
 8021040:	d013      	beq.n	802106a <I2C_ITError+0x1a2>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8021042:	687b      	ldr	r3, [r7, #4]
 8021044:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021046:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8021048:	687b      	ldr	r3, [r7, #4]
 802104a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802104c:	0018      	movs	r0, r3
 802104e:	4790      	blx	r2
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8021050:	e00b      	b.n	802106a <I2C_ITError+0x1a2>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
 8021052:	687b      	ldr	r3, [r7, #4]
 8021054:	0018      	movs	r0, r3
 8021056:	f000 f819 	bl	802108c <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 802105a:	e006      	b.n	802106a <I2C_ITError+0x1a2>
    }
  }
  else
  {
    I2C_TreatErrorCallback(hi2c);
 802105c:	687b      	ldr	r3, [r7, #4]
 802105e:	0018      	movs	r0, r3
 8021060:	f000 f814 	bl	802108c <I2C_TreatErrorCallback>
  }
}
 8021064:	e002      	b.n	802106c <I2C_ITError+0x1a4>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8021066:	46c0      	nop			; (mov r8, r8)
 8021068:	e000      	b.n	802106c <I2C_ITError+0x1a4>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 802106a:	46c0      	nop			; (mov r8, r8)
}
 802106c:	46c0      	nop			; (mov r8, r8)
 802106e:	46bd      	mov	sp, r7
 8021070:	b004      	add	sp, #16
 8021072:	bd80      	pop	{r7, pc}
 8021074:	ffff0000 	.word	0xffff0000
 8021078:	080207b9 	.word	0x080207b9
 802107c:	00008003 	.word	0x00008003
 8021080:	ffffbfff 	.word	0xffffbfff
 8021084:	08021127 	.word	0x08021127
 8021088:	ffff7fff 	.word	0xffff7fff

0802108c <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
 802108c:	b580      	push	{r7, lr}
 802108e:	b082      	sub	sp, #8
 8021090:	af00      	add	r7, sp, #0
 8021092:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8021094:	687b      	ldr	r3, [r7, #4]
 8021096:	2241      	movs	r2, #65	; 0x41
 8021098:	5c9b      	ldrb	r3, [r3, r2]
 802109a:	b2db      	uxtb	r3, r3
 802109c:	2b60      	cmp	r3, #96	; 0x60
 802109e:	d110      	bne.n	80210c2 <I2C_TreatErrorCallback+0x36>
  {
    hi2c->State = HAL_I2C_STATE_READY;
 80210a0:	687b      	ldr	r3, [r7, #4]
 80210a2:	2241      	movs	r2, #65	; 0x41
 80210a4:	2120      	movs	r1, #32
 80210a6:	5499      	strb	r1, [r3, r2]
    hi2c->PreviousState = I2C_STATE_NONE;
 80210a8:	687b      	ldr	r3, [r7, #4]
 80210aa:	2200      	movs	r2, #0
 80210ac:	631a      	str	r2, [r3, #48]	; 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80210ae:	687b      	ldr	r3, [r7, #4]
 80210b0:	2240      	movs	r2, #64	; 0x40
 80210b2:	2100      	movs	r1, #0
 80210b4:	5499      	strb	r1, [r3, r2]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
 80210b6:	687b      	ldr	r3, [r7, #4]
 80210b8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80210ba:	687a      	ldr	r2, [r7, #4]
 80210bc:	0010      	movs	r0, r2
 80210be:	4798      	blx	r3
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 80210c0:	e00b      	b.n	80210da <I2C_TreatErrorCallback+0x4e>
    hi2c->PreviousState = I2C_STATE_NONE;
 80210c2:	687b      	ldr	r3, [r7, #4]
 80210c4:	2200      	movs	r2, #0
 80210c6:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 80210c8:	687b      	ldr	r3, [r7, #4]
 80210ca:	2240      	movs	r2, #64	; 0x40
 80210cc:	2100      	movs	r1, #0
 80210ce:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCallback(hi2c);
 80210d0:	687b      	ldr	r3, [r7, #4]
 80210d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80210d4:	687a      	ldr	r2, [r7, #4]
 80210d6:	0010      	movs	r0, r2
 80210d8:	4798      	blx	r3
}
 80210da:	46c0      	nop			; (mov r8, r8)
 80210dc:	46bd      	mov	sp, r7
 80210de:	b002      	add	sp, #8
 80210e0:	bd80      	pop	{r7, pc}

080210e2 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 80210e2:	b580      	push	{r7, lr}
 80210e4:	b082      	sub	sp, #8
 80210e6:	af00      	add	r7, sp, #0
 80210e8:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80210ea:	687b      	ldr	r3, [r7, #4]
 80210ec:	681b      	ldr	r3, [r3, #0]
 80210ee:	699b      	ldr	r3, [r3, #24]
 80210f0:	2202      	movs	r2, #2
 80210f2:	4013      	ands	r3, r2
 80210f4:	2b02      	cmp	r3, #2
 80210f6:	d103      	bne.n	8021100 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 80210f8:	687b      	ldr	r3, [r7, #4]
 80210fa:	681b      	ldr	r3, [r3, #0]
 80210fc:	2200      	movs	r2, #0
 80210fe:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8021100:	687b      	ldr	r3, [r7, #4]
 8021102:	681b      	ldr	r3, [r3, #0]
 8021104:	699b      	ldr	r3, [r3, #24]
 8021106:	2201      	movs	r2, #1
 8021108:	4013      	ands	r3, r2
 802110a:	2b01      	cmp	r3, #1
 802110c:	d007      	beq.n	802111e <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 802110e:	687b      	ldr	r3, [r7, #4]
 8021110:	681b      	ldr	r3, [r3, #0]
 8021112:	699a      	ldr	r2, [r3, #24]
 8021114:	687b      	ldr	r3, [r7, #4]
 8021116:	681b      	ldr	r3, [r3, #0]
 8021118:	2101      	movs	r1, #1
 802111a:	430a      	orrs	r2, r1
 802111c:	619a      	str	r2, [r3, #24]
  }
}
 802111e:	46c0      	nop			; (mov r8, r8)
 8021120:	46bd      	mov	sp, r7
 8021122:	b002      	add	sp, #8
 8021124:	bd80      	pop	{r7, pc}

08021126 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
 8021126:	b580      	push	{r7, lr}
 8021128:	b084      	sub	sp, #16
 802112a:	af00      	add	r7, sp, #0
 802112c:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
 802112e:	687b      	ldr	r3, [r7, #4]
 8021130:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021132:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
 8021134:	68fb      	ldr	r3, [r7, #12]
 8021136:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8021138:	2b00      	cmp	r3, #0
 802113a:	d003      	beq.n	8021144 <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
 802113c:	68fb      	ldr	r3, [r7, #12]
 802113e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8021140:	2200      	movs	r2, #0
 8021142:	639a      	str	r2, [r3, #56]	; 0x38
  }
  if (hi2c->hdmarx != NULL)
 8021144:	68fb      	ldr	r3, [r7, #12]
 8021146:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021148:	2b00      	cmp	r3, #0
 802114a:	d003      	beq.n	8021154 <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
 802114c:	68fb      	ldr	r3, [r7, #12]
 802114e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021150:	2200      	movs	r2, #0
 8021152:	639a      	str	r2, [r3, #56]	; 0x38
  }

  I2C_TreatErrorCallback(hi2c);
 8021154:	68fb      	ldr	r3, [r7, #12]
 8021156:	0018      	movs	r0, r3
 8021158:	f7ff ff98 	bl	802108c <I2C_TreatErrorCallback>
}
 802115c:	46c0      	nop			; (mov r8, r8)
 802115e:	46bd      	mov	sp, r7
 8021160:	b004      	add	sp, #16
 8021162:	bd80      	pop	{r7, pc}

08021164 <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
 8021164:	b580      	push	{r7, lr}
 8021166:	b084      	sub	sp, #16
 8021168:	af00      	add	r7, sp, #0
 802116a:	6078      	str	r0, [r7, #4]
 802116c:	000a      	movs	r2, r1
 802116e:	1cbb      	adds	r3, r7, #2
 8021170:	801a      	strh	r2, [r3, #0]
  uint32_t tmpisr = 0U;
 8021172:	2300      	movs	r3, #0
 8021174:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
 8021176:	1cbb      	adds	r3, r7, #2
 8021178:	881b      	ldrh	r3, [r3, #0]
 802117a:	2201      	movs	r2, #1
 802117c:	4013      	ands	r3, r2
 802117e:	d010      	beq.n	80211a2 <I2C_Disable_IRQ+0x3e>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
 8021180:	68fb      	ldr	r3, [r7, #12]
 8021182:	2242      	movs	r2, #66	; 0x42
 8021184:	4313      	orrs	r3, r2
 8021186:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8021188:	687b      	ldr	r3, [r7, #4]
 802118a:	2241      	movs	r2, #65	; 0x41
 802118c:	5c9b      	ldrb	r3, [r3, r2]
 802118e:	b2db      	uxtb	r3, r3
 8021190:	001a      	movs	r2, r3
 8021192:	2328      	movs	r3, #40	; 0x28
 8021194:	4013      	ands	r3, r2
 8021196:	2b28      	cmp	r3, #40	; 0x28
 8021198:	d003      	beq.n	80211a2 <I2C_Disable_IRQ+0x3e>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 802119a:	68fb      	ldr	r3, [r7, #12]
 802119c:	22b0      	movs	r2, #176	; 0xb0
 802119e:	4313      	orrs	r3, r2
 80211a0:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
 80211a2:	1cbb      	adds	r3, r7, #2
 80211a4:	881b      	ldrh	r3, [r3, #0]
 80211a6:	2202      	movs	r2, #2
 80211a8:	4013      	ands	r3, r2
 80211aa:	d010      	beq.n	80211ce <I2C_Disable_IRQ+0x6a>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
 80211ac:	68fb      	ldr	r3, [r7, #12]
 80211ae:	2244      	movs	r2, #68	; 0x44
 80211b0:	4313      	orrs	r3, r2
 80211b2:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80211b4:	687b      	ldr	r3, [r7, #4]
 80211b6:	2241      	movs	r2, #65	; 0x41
 80211b8:	5c9b      	ldrb	r3, [r3, r2]
 80211ba:	b2db      	uxtb	r3, r3
 80211bc:	001a      	movs	r2, r3
 80211be:	2328      	movs	r3, #40	; 0x28
 80211c0:	4013      	ands	r3, r2
 80211c2:	2b28      	cmp	r3, #40	; 0x28
 80211c4:	d003      	beq.n	80211ce <I2C_Disable_IRQ+0x6a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 80211c6:	68fb      	ldr	r3, [r7, #12]
 80211c8:	22b0      	movs	r2, #176	; 0xb0
 80211ca:	4313      	orrs	r3, r2
 80211cc:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
 80211ce:	1cbb      	adds	r3, r7, #2
 80211d0:	2200      	movs	r2, #0
 80211d2:	5e9b      	ldrsh	r3, [r3, r2]
 80211d4:	2b00      	cmp	r3, #0
 80211d6:	da03      	bge.n	80211e0 <I2C_Disable_IRQ+0x7c>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 80211d8:	68fb      	ldr	r3, [r7, #12]
 80211da:	22b8      	movs	r2, #184	; 0xb8
 80211dc:	4313      	orrs	r3, r2
 80211de:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
 80211e0:	1cbb      	adds	r3, r7, #2
 80211e2:	881b      	ldrh	r3, [r3, #0]
 80211e4:	2b10      	cmp	r3, #16
 80211e6:	d103      	bne.n	80211f0 <I2C_Disable_IRQ+0x8c>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
 80211e8:	68fb      	ldr	r3, [r7, #12]
 80211ea:	2290      	movs	r2, #144	; 0x90
 80211ec:	4313      	orrs	r3, r2
 80211ee:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
 80211f0:	1cbb      	adds	r3, r7, #2
 80211f2:	881b      	ldrh	r3, [r3, #0]
 80211f4:	2b20      	cmp	r3, #32
 80211f6:	d103      	bne.n	8021200 <I2C_Disable_IRQ+0x9c>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
 80211f8:	68fb      	ldr	r3, [r7, #12]
 80211fa:	2220      	movs	r2, #32
 80211fc:	4313      	orrs	r3, r2
 80211fe:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
 8021200:	1cbb      	adds	r3, r7, #2
 8021202:	881b      	ldrh	r3, [r3, #0]
 8021204:	2b40      	cmp	r3, #64	; 0x40
 8021206:	d103      	bne.n	8021210 <I2C_Disable_IRQ+0xac>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
 8021208:	68fb      	ldr	r3, [r7, #12]
 802120a:	2240      	movs	r2, #64	; 0x40
 802120c:	4313      	orrs	r3, r2
 802120e:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8021210:	687b      	ldr	r3, [r7, #4]
 8021212:	681b      	ldr	r3, [r3, #0]
 8021214:	681a      	ldr	r2, [r3, #0]
 8021216:	68fb      	ldr	r3, [r7, #12]
 8021218:	43d9      	mvns	r1, r3
 802121a:	687b      	ldr	r3, [r7, #4]
 802121c:	681b      	ldr	r3, [r3, #0]
 802121e:	400a      	ands	r2, r1
 8021220:	601a      	str	r2, [r3, #0]
}
 8021222:	46c0      	nop			; (mov r8, r8)
 8021224:	46bd      	mov	sp, r7
 8021226:	b004      	add	sp, #16
 8021228:	bd80      	pop	{r7, pc}
	...

0802122c <HAL_IPCC_TX_IRQHandler>:
  * @brief  This function handles IPCC Tx Free interrupt request.
  * @param  hipcc IPCC handle
  * @retval None
  */
void HAL_IPCC_TX_IRQHandler(IPCC_HandleTypeDef *const hipcc)
{
 802122c:	b580      	push	{r7, lr}
 802122e:	b086      	sub	sp, #24
 8021230:	af00      	add	r7, sp, #0
 8021232:	6078      	str	r0, [r7, #4]
  uint32_t irqmask;
  uint32_t bit_pos;
  uint32_t ch_count = 0U;
 8021234:	2300      	movs	r3, #0
 8021236:	613b      	str	r3, [r7, #16]
#if defined(CORE_CM0PLUS)
  IPCC_CommonTypeDef *currentInstance = IPCC_C2;
 8021238:	4b23      	ldr	r3, [pc, #140]	; (80212c8 <HAL_IPCC_TX_IRQHandler+0x9c>)
 802123a:	60fb      	str	r3, [r7, #12]
#else
  IPCC_CommonTypeDef *currentInstance = IPCC_C1;
#endif

  /* check the Tx free channels which are not masked */
  irqmask = ~(currentInstance->MR) & IPCC_ALL_TX_BUF;
 802123c:	68fb      	ldr	r3, [r7, #12]
 802123e:	685b      	ldr	r3, [r3, #4]
 8021240:	43da      	mvns	r2, r3
 8021242:	23fc      	movs	r3, #252	; 0xfc
 8021244:	039b      	lsls	r3, r3, #14
 8021246:	4013      	ands	r3, r2
 8021248:	617b      	str	r3, [r7, #20]
  irqmask = irqmask & ~(currentInstance->SR << IPCC_MR_CH1FM_Pos);
 802124a:	68fb      	ldr	r3, [r7, #12]
 802124c:	68db      	ldr	r3, [r3, #12]
 802124e:	041b      	lsls	r3, r3, #16
 8021250:	43da      	mvns	r2, r3
 8021252:	697b      	ldr	r3, [r7, #20]
 8021254:	4013      	ands	r3, r2
 8021256:	617b      	str	r3, [r7, #20]

  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8021258:	e02d      	b.n	80212b6 <HAL_IPCC_TX_IRQHandler+0x8a>
  {
    bit_pos = 1UL << (IPCC_MR_CH1FM_Pos + (ch_count & CHANNEL_INDEX_Msk));
 802125a:	693b      	ldr	r3, [r7, #16]
 802125c:	220f      	movs	r2, #15
 802125e:	4013      	ands	r3, r2
 8021260:	3310      	adds	r3, #16
 8021262:	2201      	movs	r2, #1
 8021264:	409a      	lsls	r2, r3
 8021266:	0013      	movs	r3, r2
 8021268:	60bb      	str	r3, [r7, #8]

    if ((irqmask & bit_pos) != 0U)
 802126a:	697b      	ldr	r3, [r7, #20]
 802126c:	68ba      	ldr	r2, [r7, #8]
 802126e:	4013      	ands	r3, r2
 8021270:	d01e      	beq.n	80212b0 <HAL_IPCC_TX_IRQHandler+0x84>
    {
      /* mask the channel Free interrupt  */
      currentInstance->MR |= bit_pos;
 8021272:	68fb      	ldr	r3, [r7, #12]
 8021274:	685a      	ldr	r2, [r3, #4]
 8021276:	68bb      	ldr	r3, [r7, #8]
 8021278:	431a      	orrs	r2, r3
 802127a:	68fb      	ldr	r3, [r7, #12]
 802127c:	605a      	str	r2, [r3, #4]
      if (hipcc->ChannelCallbackTx[ch_count] != NULL)
 802127e:	687a      	ldr	r2, [r7, #4]
 8021280:	693b      	ldr	r3, [r7, #16]
 8021282:	3306      	adds	r3, #6
 8021284:	009b      	lsls	r3, r3, #2
 8021286:	18d3      	adds	r3, r2, r3
 8021288:	3304      	adds	r3, #4
 802128a:	681b      	ldr	r3, [r3, #0]
 802128c:	2b00      	cmp	r3, #0
 802128e:	d00a      	beq.n	80212a6 <HAL_IPCC_TX_IRQHandler+0x7a>
      {
        hipcc->ChannelCallbackTx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_TX);
 8021290:	687a      	ldr	r2, [r7, #4]
 8021292:	693b      	ldr	r3, [r7, #16]
 8021294:	3306      	adds	r3, #6
 8021296:	009b      	lsls	r3, r3, #2
 8021298:	18d3      	adds	r3, r2, r3
 802129a:	3304      	adds	r3, #4
 802129c:	681b      	ldr	r3, [r3, #0]
 802129e:	6939      	ldr	r1, [r7, #16]
 80212a0:	6878      	ldr	r0, [r7, #4]
 80212a2:	2200      	movs	r2, #0
 80212a4:	4798      	blx	r3
      }
      irqmask =  irqmask & ~(bit_pos);
 80212a6:	68bb      	ldr	r3, [r7, #8]
 80212a8:	43da      	mvns	r2, r3
 80212aa:	697b      	ldr	r3, [r7, #20]
 80212ac:	4013      	ands	r3, r2
 80212ae:	617b      	str	r3, [r7, #20]
    }
    ch_count++;
 80212b0:	693b      	ldr	r3, [r7, #16]
 80212b2:	3301      	adds	r3, #1
 80212b4:	613b      	str	r3, [r7, #16]
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 80212b6:	697b      	ldr	r3, [r7, #20]
 80212b8:	2b00      	cmp	r3, #0
 80212ba:	d1ce      	bne.n	802125a <HAL_IPCC_TX_IRQHandler+0x2e>
  }
}
 80212bc:	46c0      	nop			; (mov r8, r8)
 80212be:	46c0      	nop			; (mov r8, r8)
 80212c0:	46bd      	mov	sp, r7
 80212c2:	b006      	add	sp, #24
 80212c4:	bd80      	pop	{r7, pc}
 80212c6:	46c0      	nop			; (mov r8, r8)
 80212c8:	58000c10 	.word	0x58000c10

080212cc <HAL_IPCC_RX_IRQHandler>:
  * @brief  This function handles IPCC Rx Occupied interrupt request.
  * @param  hipcc : IPCC handle
  * @retval None
  */
void HAL_IPCC_RX_IRQHandler(IPCC_HandleTypeDef *const hipcc)
{
 80212cc:	b580      	push	{r7, lr}
 80212ce:	b088      	sub	sp, #32
 80212d0:	af00      	add	r7, sp, #0
 80212d2:	6078      	str	r0, [r7, #4]
  uint32_t irqmask;
  uint32_t bit_pos;
  uint32_t ch_count = 0U;
 80212d4:	2300      	movs	r3, #0
 80212d6:	61bb      	str	r3, [r7, #24]
#if defined(CORE_CM0PLUS)
  IPCC_CommonTypeDef *currentInstance = IPCC_C2;
 80212d8:	4b21      	ldr	r3, [pc, #132]	; (8021360 <HAL_IPCC_RX_IRQHandler+0x94>)
 80212da:	617b      	str	r3, [r7, #20]
  IPCC_CommonTypeDef *otherInstance = IPCC_C1;
 80212dc:	4b21      	ldr	r3, [pc, #132]	; (8021364 <HAL_IPCC_RX_IRQHandler+0x98>)
 80212de:	613b      	str	r3, [r7, #16]
  IPCC_CommonTypeDef *currentInstance = IPCC_C1;
  IPCC_CommonTypeDef *otherInstance = IPCC_C2;
#endif

  /* check the Rx occupied channels which are not masked */
  irqmask = ~(currentInstance->MR) & IPCC_ALL_RX_BUF;
 80212e0:	697b      	ldr	r3, [r7, #20]
 80212e2:	685b      	ldr	r3, [r3, #4]
 80212e4:	43db      	mvns	r3, r3
 80212e6:	223f      	movs	r2, #63	; 0x3f
 80212e8:	4013      	ands	r3, r2
 80212ea:	61fb      	str	r3, [r7, #28]
  irqmask = irqmask & otherInstance->SR;
 80212ec:	693b      	ldr	r3, [r7, #16]
 80212ee:	68da      	ldr	r2, [r3, #12]
 80212f0:	69fb      	ldr	r3, [r7, #28]
 80212f2:	4013      	ands	r3, r2
 80212f4:	61fb      	str	r3, [r7, #28]

  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 80212f6:	e02a      	b.n	802134e <HAL_IPCC_RX_IRQHandler+0x82>
  {
    bit_pos = 1UL << (ch_count & CHANNEL_INDEX_Msk);
 80212f8:	69bb      	ldr	r3, [r7, #24]
 80212fa:	220f      	movs	r2, #15
 80212fc:	4013      	ands	r3, r2
 80212fe:	2201      	movs	r2, #1
 8021300:	409a      	lsls	r2, r3
 8021302:	0013      	movs	r3, r2
 8021304:	60fb      	str	r3, [r7, #12]

    if ((irqmask & bit_pos) != 0U)
 8021306:	69fb      	ldr	r3, [r7, #28]
 8021308:	68fa      	ldr	r2, [r7, #12]
 802130a:	4013      	ands	r3, r2
 802130c:	d01c      	beq.n	8021348 <HAL_IPCC_RX_IRQHandler+0x7c>
    {
      /* mask the channel occupied interrupt */
      currentInstance->MR |= bit_pos;
 802130e:	697b      	ldr	r3, [r7, #20]
 8021310:	685a      	ldr	r2, [r3, #4]
 8021312:	68fb      	ldr	r3, [r7, #12]
 8021314:	431a      	orrs	r2, r3
 8021316:	697b      	ldr	r3, [r7, #20]
 8021318:	605a      	str	r2, [r3, #4]
      if (hipcc->ChannelCallbackRx[ch_count] != NULL)
 802131a:	687a      	ldr	r2, [r7, #4]
 802131c:	69bb      	ldr	r3, [r7, #24]
 802131e:	009b      	lsls	r3, r3, #2
 8021320:	18d3      	adds	r3, r2, r3
 8021322:	3304      	adds	r3, #4
 8021324:	681b      	ldr	r3, [r3, #0]
 8021326:	2b00      	cmp	r3, #0
 8021328:	d009      	beq.n	802133e <HAL_IPCC_RX_IRQHandler+0x72>
      {
        hipcc->ChannelCallbackRx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_RX);
 802132a:	687a      	ldr	r2, [r7, #4]
 802132c:	69bb      	ldr	r3, [r7, #24]
 802132e:	009b      	lsls	r3, r3, #2
 8021330:	18d3      	adds	r3, r2, r3
 8021332:	3304      	adds	r3, #4
 8021334:	681b      	ldr	r3, [r3, #0]
 8021336:	69b9      	ldr	r1, [r7, #24]
 8021338:	6878      	ldr	r0, [r7, #4]
 802133a:	2201      	movs	r2, #1
 802133c:	4798      	blx	r3
      }
      irqmask = irqmask & ~(bit_pos);
 802133e:	68fb      	ldr	r3, [r7, #12]
 8021340:	43da      	mvns	r2, r3
 8021342:	69fb      	ldr	r3, [r7, #28]
 8021344:	4013      	ands	r3, r2
 8021346:	61fb      	str	r3, [r7, #28]
    }
    ch_count++;
 8021348:	69bb      	ldr	r3, [r7, #24]
 802134a:	3301      	adds	r3, #1
 802134c:	61bb      	str	r3, [r7, #24]
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 802134e:	69fb      	ldr	r3, [r7, #28]
 8021350:	2b00      	cmp	r3, #0
 8021352:	d1d1      	bne.n	80212f8 <HAL_IPCC_RX_IRQHandler+0x2c>
  }
}
 8021354:	46c0      	nop			; (mov r8, r8)
 8021356:	46c0      	nop			; (mov r8, r8)
 8021358:	46bd      	mov	sp, r7
 802135a:	b008      	add	sp, #32
 802135c:	bd80      	pop	{r7, pc}
 802135e:	46c0      	nop			; (mov r8, r8)
 8021360:	58000c10 	.word	0x58000c10
 8021364:	58000c00 	.word	0x58000c00

08021368 <LL_RCC_HSE_IsEnabledDiv2>:
  * @brief  Get HSE sysclk and pll prescaler  division by 2
  * @rmtoll CR           HSEPRE        LL_RCC_HSE_IsEnabledDiv2
  * @retval None
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsEnabledDiv2(void)
{
 8021368:	b580      	push	{r7, lr}
 802136a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802136c:	23b0      	movs	r3, #176	; 0xb0
 802136e:	05db      	lsls	r3, r3, #23
 8021370:	681a      	ldr	r2, [r3, #0]
 8021372:	2380      	movs	r3, #128	; 0x80
 8021374:	035b      	lsls	r3, r3, #13
 8021376:	401a      	ands	r2, r3
 8021378:	2380      	movs	r3, #128	; 0x80
 802137a:	035b      	lsls	r3, r3, #13
 802137c:	429a      	cmp	r2, r3
 802137e:	d101      	bne.n	8021384 <LL_RCC_HSE_IsEnabledDiv2+0x1c>
 8021380:	2301      	movs	r3, #1
 8021382:	e000      	b.n	8021386 <LL_RCC_HSE_IsEnabledDiv2+0x1e>
 8021384:	2300      	movs	r3, #0
}
 8021386:	0018      	movs	r0, r3
 8021388:	46bd      	mov	sp, r7
 802138a:	bd80      	pop	{r7, pc}

0802138c <LL_RCC_MSI_IsEnabledRangeSelect>:
  * @brief  Check if MSI clock range is selected with MSIRANGE register
  * @rmtoll CR           MSIRGSEL      LL_RCC_MSI_IsEnabledRangeSelect
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsEnabledRangeSelect(void)
{
 802138c:	b580      	push	{r7, lr}
 802138e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8021390:	23b0      	movs	r3, #176	; 0xb0
 8021392:	05db      	lsls	r3, r3, #23
 8021394:	681b      	ldr	r3, [r3, #0]
 8021396:	2208      	movs	r2, #8
 8021398:	4013      	ands	r3, r2
 802139a:	2b08      	cmp	r3, #8
 802139c:	d101      	bne.n	80213a2 <LL_RCC_MSI_IsEnabledRangeSelect+0x16>
 802139e:	2301      	movs	r3, #1
 80213a0:	e000      	b.n	80213a4 <LL_RCC_MSI_IsEnabledRangeSelect+0x18>
 80213a2:	2300      	movs	r3, #0
}
 80213a4:	0018      	movs	r0, r3
 80213a6:	46bd      	mov	sp, r7
 80213a8:	bd80      	pop	{r7, pc}

080213aa <LL_RCC_MSI_GetRange>:
  *         @arg @ref LL_RCC_MSIRANGE_9
  *         @arg @ref LL_RCC_MSIRANGE_10
  *         @arg @ref LL_RCC_MSIRANGE_11
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetRange(void)
{
 80213aa:	b580      	push	{r7, lr}
 80213ac:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 80213ae:	23b0      	movs	r3, #176	; 0xb0
 80213b0:	05db      	lsls	r3, r3, #23
 80213b2:	681b      	ldr	r3, [r3, #0]
 80213b4:	22f0      	movs	r2, #240	; 0xf0
 80213b6:	4013      	ands	r3, r2
}
 80213b8:	0018      	movs	r0, r3
 80213ba:	46bd      	mov	sp, r7
 80213bc:	bd80      	pop	{r7, pc}

080213be <LL_RCC_MSI_GetRangeAfterStandby>:
  *         @arg @ref LL_RCC_MSISRANGE_5
  *         @arg @ref LL_RCC_MSISRANGE_6
  *         @arg @ref LL_RCC_MSISRANGE_7
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetRangeAfterStandby(void)
{
 80213be:	b580      	push	{r7, lr}
 80213c0:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 80213c2:	23b0      	movs	r3, #176	; 0xb0
 80213c4:	05db      	lsls	r3, r3, #23
 80213c6:	2294      	movs	r2, #148	; 0x94
 80213c8:	589a      	ldr	r2, [r3, r2]
 80213ca:	23f0      	movs	r3, #240	; 0xf0
 80213cc:	011b      	lsls	r3, r3, #4
 80213ce:	4013      	ands	r3, r2
}
 80213d0:	0018      	movs	r0, r3
 80213d2:	46bd      	mov	sp, r7
 80213d4:	bd80      	pop	{r7, pc}

080213d6 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_PLL
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
 80213d6:	b580      	push	{r7, lr}
 80213d8:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80213da:	23b0      	movs	r3, #176	; 0xb0
 80213dc:	05db      	lsls	r3, r3, #23
 80213de:	689b      	ldr	r3, [r3, #8]
 80213e0:	220c      	movs	r2, #12
 80213e2:	4013      	ands	r3, r2
}
 80213e4:	0018      	movs	r0, r3
 80213e6:	46bd      	mov	sp, r7
 80213e8:	bd80      	pop	{r7, pc}

080213ea <LL_C2_RCC_GetAHBPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_128
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_C2_RCC_GetAHBPrescaler(void)
{
 80213ea:	b580      	push	{r7, lr}
 80213ec:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE));
 80213ee:	23b0      	movs	r3, #176	; 0xb0
 80213f0:	05da      	lsls	r2, r3, #23
 80213f2:	2384      	movs	r3, #132	; 0x84
 80213f4:	005b      	lsls	r3, r3, #1
 80213f6:	58d3      	ldr	r3, [r2, r3]
 80213f8:	22f0      	movs	r2, #240	; 0xf0
 80213fa:	4013      	ands	r3, r2
}
 80213fc:	0018      	movs	r0, r3
 80213fe:	46bd      	mov	sp, r7
 8021400:	bd80      	pop	{r7, pc}

08021402 <LL_RCC_PLL_GetN>:
  * @brief  Get Main PLL multiplication factor for VCO
  * @rmtoll PLLCFGR      PLLN          LL_RCC_PLL_GetN
  * @retval Between 6 and 127
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetN(void)
{
 8021402:	b580      	push	{r7, lr}
 8021404:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8021406:	23b0      	movs	r3, #176	; 0xb0
 8021408:	05db      	lsls	r3, r3, #23
 802140a:	68db      	ldr	r3, [r3, #12]
 802140c:	0a1b      	lsrs	r3, r3, #8
 802140e:	227f      	movs	r2, #127	; 0x7f
 8021410:	4013      	ands	r3, r2
}
 8021412:	0018      	movs	r0, r3
 8021414:	46bd      	mov	sp, r7
 8021416:	bd80      	pop	{r7, pc}

08021418 <LL_RCC_PLL_GetR>:
  *         @arg @ref LL_RCC_PLLR_DIV_6
  *         @arg @ref LL_RCC_PLLR_DIV_7
  *         @arg @ref LL_RCC_PLLR_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetR(void)
{
 8021418:	b580      	push	{r7, lr}
 802141a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 802141c:	23b0      	movs	r3, #176	; 0xb0
 802141e:	05db      	lsls	r3, r3, #23
 8021420:	68db      	ldr	r3, [r3, #12]
 8021422:	0f5b      	lsrs	r3, r3, #29
 8021424:	075b      	lsls	r3, r3, #29
}
 8021426:	0018      	movs	r0, r3
 8021428:	46bd      	mov	sp, r7
 802142a:	bd80      	pop	{r7, pc}

0802142c <LL_RCC_PLL_GetDivider>:
  *         @arg @ref LL_RCC_PLLM_DIV_6
  *         @arg @ref LL_RCC_PLLM_DIV_7
  *         @arg @ref LL_RCC_PLLM_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
 802142c:	b580      	push	{r7, lr}
 802142e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8021430:	23b0      	movs	r3, #176	; 0xb0
 8021432:	05db      	lsls	r3, r3, #23
 8021434:	68db      	ldr	r3, [r3, #12]
 8021436:	2270      	movs	r2, #112	; 0x70
 8021438:	4013      	ands	r3, r2
}
 802143a:	0018      	movs	r0, r3
 802143c:	46bd      	mov	sp, r7
 802143e:	bd80      	pop	{r7, pc}

08021440 <LL_RCC_PLL_GetMainSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
 8021440:	b580      	push	{r7, lr}
 8021442:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8021444:	23b0      	movs	r3, #176	; 0xb0
 8021446:	05db      	lsls	r3, r3, #23
 8021448:	68db      	ldr	r3, [r3, #12]
 802144a:	2203      	movs	r2, #3
 802144c:	4013      	ands	r3, r2
}
 802144e:	0018      	movs	r0, r3
 8021450:	46bd      	mov	sp, r7
 8021452:	bd80      	pop	{r7, pc}

08021454 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8021454:	b590      	push	{r4, r7, lr}
 8021456:	b087      	sub	sp, #28
 8021458:	af00      	add	r7, sp, #0
  uint32_t sysclk_source;
  uint32_t pllsource;
  uint32_t sysclockfreq = 0U;
 802145a:	2300      	movs	r3, #0
 802145c:	617b      	str	r3, [r7, #20]
  uint32_t msifreq = 0U;
 802145e:	2300      	movs	r3, #0
 8021460:	613b      	str	r3, [r7, #16]
  uint32_t pllinputfreq;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8021462:	f7ff ffb8 	bl	80213d6 <LL_RCC_GetSysClkSource>
 8021466:	0003      	movs	r3, r0
 8021468:	60bb      	str	r3, [r7, #8]
  pllsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 802146a:	f7ff ffe9 	bl	8021440 <LL_RCC_PLL_GetMainSource>
 802146e:	0003      	movs	r3, r0
 8021470:	607b      	str	r3, [r7, #4]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8021472:	68bb      	ldr	r3, [r7, #8]
 8021474:	2b00      	cmp	r3, #0
 8021476:	d005      	beq.n	8021484 <HAL_RCC_GetSysClockFreq+0x30>
 8021478:	68bb      	ldr	r3, [r7, #8]
 802147a:	2b0c      	cmp	r3, #12
 802147c:	d138      	bne.n	80214f0 <HAL_RCC_GetSysClockFreq+0x9c>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 802147e:	687b      	ldr	r3, [r7, #4]
 8021480:	2b01      	cmp	r3, #1
 8021482:	d135      	bne.n	80214f0 <HAL_RCC_GetSysClockFreq+0x9c>
  {
    /* MSI or PLL with MSI source used as system clock source */
    /* Retrieve MSI frequency range in Hz */
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8021484:	f7ff ff82 	bl	802138c <LL_RCC_MSI_IsEnabledRangeSelect>
 8021488:	1e03      	subs	r3, r0, #0
 802148a:	d115      	bne.n	80214b8 <HAL_RCC_GetSysClockFreq+0x64>
 802148c:	f7ff ff7e 	bl	802138c <LL_RCC_MSI_IsEnabledRangeSelect>
 8021490:	0003      	movs	r3, r0
 8021492:	2b01      	cmp	r3, #1
 8021494:	d106      	bne.n	80214a4 <HAL_RCC_GetSysClockFreq+0x50>
 8021496:	f7ff ff88 	bl	80213aa <LL_RCC_MSI_GetRange>
 802149a:	0003      	movs	r3, r0
 802149c:	0a1b      	lsrs	r3, r3, #8
 802149e:	220f      	movs	r2, #15
 80214a0:	4013      	ands	r3, r2
 80214a2:	e005      	b.n	80214b0 <HAL_RCC_GetSysClockFreq+0x5c>
 80214a4:	f7ff ff8b 	bl	80213be <LL_RCC_MSI_GetRangeAfterStandby>
 80214a8:	0003      	movs	r3, r0
 80214aa:	0a1b      	lsrs	r3, r3, #8
 80214ac:	220f      	movs	r2, #15
 80214ae:	4013      	ands	r3, r2
 80214b0:	4a3a      	ldr	r2, [pc, #232]	; (802159c <HAL_RCC_GetSysClockFreq+0x148>)
 80214b2:	009b      	lsls	r3, r3, #2
 80214b4:	589b      	ldr	r3, [r3, r2]
 80214b6:	e014      	b.n	80214e2 <HAL_RCC_GetSysClockFreq+0x8e>
 80214b8:	f7ff ff68 	bl	802138c <LL_RCC_MSI_IsEnabledRangeSelect>
 80214bc:	0003      	movs	r3, r0
 80214be:	2b01      	cmp	r3, #1
 80214c0:	d106      	bne.n	80214d0 <HAL_RCC_GetSysClockFreq+0x7c>
 80214c2:	f7ff ff72 	bl	80213aa <LL_RCC_MSI_GetRange>
 80214c6:	0003      	movs	r3, r0
 80214c8:	091b      	lsrs	r3, r3, #4
 80214ca:	220f      	movs	r2, #15
 80214cc:	4013      	ands	r3, r2
 80214ce:	e005      	b.n	80214dc <HAL_RCC_GetSysClockFreq+0x88>
 80214d0:	f7ff ff75 	bl	80213be <LL_RCC_MSI_GetRangeAfterStandby>
 80214d4:	0003      	movs	r3, r0
 80214d6:	091b      	lsrs	r3, r3, #4
 80214d8:	220f      	movs	r2, #15
 80214da:	4013      	ands	r3, r2
 80214dc:	4a2f      	ldr	r2, [pc, #188]	; (802159c <HAL_RCC_GetSysClockFreq+0x148>)
 80214de:	009b      	lsls	r3, r3, #2
 80214e0:	589b      	ldr	r3, [r3, r2]
 80214e2:	613b      	str	r3, [r7, #16]
                                     ((LL_RCC_MSI_IsEnabledRangeSelect() == 1U) ?
                                      LL_RCC_MSI_GetRange() :
                                      LL_RCC_MSI_GetRangeAfterStandby()));

    /* Get SYSCLK source */
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 80214e4:	68bb      	ldr	r3, [r7, #8]
 80214e6:	2b00      	cmp	r3, #0
 80214e8:	d115      	bne.n	8021516 <HAL_RCC_GetSysClockFreq+0xc2>
    {
      /* MSI used as system clock source */
      sysclockfreq = msifreq;
 80214ea:	693b      	ldr	r3, [r7, #16]
 80214ec:	617b      	str	r3, [r7, #20]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 80214ee:	e012      	b.n	8021516 <HAL_RCC_GetSysClockFreq+0xc2>
    }
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80214f0:	68bb      	ldr	r3, [r7, #8]
 80214f2:	2b04      	cmp	r3, #4
 80214f4:	d102      	bne.n	80214fc <HAL_RCC_GetSysClockFreq+0xa8>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 80214f6:	4b2a      	ldr	r3, [pc, #168]	; (80215a0 <HAL_RCC_GetSysClockFreq+0x14c>)
 80214f8:	617b      	str	r3, [r7, #20]
 80214fa:	e00c      	b.n	8021516 <HAL_RCC_GetSysClockFreq+0xc2>
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 80214fc:	68bb      	ldr	r3, [r7, #8]
 80214fe:	2b08      	cmp	r3, #8
 8021500:	d109      	bne.n	8021516 <HAL_RCC_GetSysClockFreq+0xc2>
  {
    /* HSE used as system clock source */
    if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8021502:	f7ff ff31 	bl	8021368 <LL_RCC_HSE_IsEnabledDiv2>
 8021506:	0003      	movs	r3, r0
 8021508:	2b01      	cmp	r3, #1
 802150a:	d102      	bne.n	8021512 <HAL_RCC_GetSysClockFreq+0xbe>
    {
      sysclockfreq = HSE_VALUE / 2U;
 802150c:	4b24      	ldr	r3, [pc, #144]	; (80215a0 <HAL_RCC_GetSysClockFreq+0x14c>)
 802150e:	617b      	str	r3, [r7, #20]
 8021510:	e001      	b.n	8021516 <HAL_RCC_GetSysClockFreq+0xc2>
    }
    else
    {
      sysclockfreq = HSE_VALUE;
 8021512:	4b24      	ldr	r3, [pc, #144]	; (80215a4 <HAL_RCC_GetSysClockFreq+0x150>)
 8021514:	617b      	str	r3, [r7, #20]
  else
  {
    /* Nothing to do */
  }

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8021516:	f7ff ff5e 	bl	80213d6 <LL_RCC_GetSysClkSource>
 802151a:	0003      	movs	r3, r0
 802151c:	2b0c      	cmp	r3, #12
 802151e:	d137      	bne.n	8021590 <HAL_RCC_GetSysClockFreq+0x13c>
  {
    /* PLL used as system clock  source */
    pllsource = LL_RCC_PLL_GetMainSource();
 8021520:	f7ff ff8e 	bl	8021440 <LL_RCC_PLL_GetMainSource>
 8021524:	0003      	movs	r3, r0
 8021526:	607b      	str	r3, [r7, #4]

    switch (pllsource)
 8021528:	687b      	ldr	r3, [r7, #4]
 802152a:	2b02      	cmp	r3, #2
 802152c:	d003      	beq.n	8021536 <HAL_RCC_GetSysClockFreq+0xe2>
 802152e:	687b      	ldr	r3, [r7, #4]
 8021530:	2b03      	cmp	r3, #3
 8021532:	d003      	beq.n	802153c <HAL_RCC_GetSysClockFreq+0xe8>
 8021534:	e00d      	b.n	8021552 <HAL_RCC_GetSysClockFreq+0xfe>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllinputfreq = HSI_VALUE;
 8021536:	4b1a      	ldr	r3, [pc, #104]	; (80215a0 <HAL_RCC_GetSysClockFreq+0x14c>)
 8021538:	60fb      	str	r3, [r7, #12]
        break;
 802153a:	e00d      	b.n	8021558 <HAL_RCC_GetSysClockFreq+0x104>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 802153c:	f7ff ff14 	bl	8021368 <LL_RCC_HSE_IsEnabledDiv2>
 8021540:	0003      	movs	r3, r0
 8021542:	2b01      	cmp	r3, #1
 8021544:	d102      	bne.n	802154c <HAL_RCC_GetSysClockFreq+0xf8>
        {
          pllinputfreq = HSE_VALUE / 2U;
 8021546:	4b16      	ldr	r3, [pc, #88]	; (80215a0 <HAL_RCC_GetSysClockFreq+0x14c>)
 8021548:	60fb      	str	r3, [r7, #12]
        }
        else
        {
          pllinputfreq = HSE_VALUE;
        }
        break;
 802154a:	e005      	b.n	8021558 <HAL_RCC_GetSysClockFreq+0x104>
          pllinputfreq = HSE_VALUE;
 802154c:	4b15      	ldr	r3, [pc, #84]	; (80215a4 <HAL_RCC_GetSysClockFreq+0x150>)
 802154e:	60fb      	str	r3, [r7, #12]
        break;
 8021550:	e002      	b.n	8021558 <HAL_RCC_GetSysClockFreq+0x104>
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllinputfreq = msifreq;
 8021552:	693b      	ldr	r3, [r7, #16]
 8021554:	60fb      	str	r3, [r7, #12]
        break;
 8021556:	46c0      	nop			; (mov r8, r8)
    }
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8021558:	f7ff ff53 	bl	8021402 <LL_RCC_PLL_GetN>
 802155c:	0002      	movs	r2, r0
 802155e:	68fb      	ldr	r3, [r7, #12]
 8021560:	4353      	muls	r3, r2
 8021562:	001c      	movs	r4, r3
 8021564:	f7ff ff62 	bl	802142c <LL_RCC_PLL_GetDivider>
 8021568:	0003      	movs	r3, r0
 802156a:	091b      	lsrs	r3, r3, #4
 802156c:	3301      	adds	r3, #1
 802156e:	0019      	movs	r1, r3
 8021570:	0020      	movs	r0, r4
 8021572:	f7fe fdc9 	bl	8020108 <__udivsi3>
 8021576:	0003      	movs	r3, r0
 8021578:	001c      	movs	r4, r3
 802157a:	f7ff ff4d 	bl	8021418 <LL_RCC_PLL_GetR>
 802157e:	0003      	movs	r3, r0
 8021580:	0f5b      	lsrs	r3, r3, #29
 8021582:	3301      	adds	r3, #1
 8021584:	0019      	movs	r1, r3
 8021586:	0020      	movs	r0, r4
 8021588:	f7fe fdbe 	bl	8020108 <__udivsi3>
 802158c:	0003      	movs	r3, r0
 802158e:	617b      	str	r3, [r7, #20]
                                             LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
 8021590:	697b      	ldr	r3, [r7, #20]
}
 8021592:	0018      	movs	r0, r3
 8021594:	46bd      	mov	sp, r7
 8021596:	b007      	add	sp, #28
 8021598:	bd90      	pop	{r4, r7, pc}
 802159a:	46c0      	nop			; (mov r8, r8)
 802159c:	08021928 	.word	0x08021928
 80215a0:	00f42400 	.word	0x00f42400
 80215a4:	01e84800 	.word	0x01e84800

080215a8 <HAL_RCC_GetHCLK2Freq>:
/**
  * @brief  Return the HCLK2 frequency.
  * @retval HCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetHCLK2Freq(void)
{
 80215a8:	b5b0      	push	{r4, r5, r7, lr}
 80215aa:	af00      	add	r7, sp, #0
  /* Get SysClock and Compute HCLK2 frequency --------------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK2_FREQ(HAL_RCC_GetSysClockFreq(), LL_C2_RCC_GetAHBPrescaler())));
 80215ac:	f7ff ff52 	bl	8021454 <HAL_RCC_GetSysClockFreq>
 80215b0:	0004      	movs	r4, r0
 80215b2:	f7ff ff1a 	bl	80213ea <LL_C2_RCC_GetAHBPrescaler>
 80215b6:	0003      	movs	r3, r0
 80215b8:	091b      	lsrs	r3, r3, #4
 80215ba:	220f      	movs	r2, #15
 80215bc:	401a      	ands	r2, r3
 80215be:	4b05      	ldr	r3, [pc, #20]	; (80215d4 <HAL_RCC_GetHCLK2Freq+0x2c>)
 80215c0:	0092      	lsls	r2, r2, #2
 80215c2:	58d3      	ldr	r3, [r2, r3]
 80215c4:	0019      	movs	r1, r3
 80215c6:	0020      	movs	r0, r4
 80215c8:	f7fe fd9e 	bl	8020108 <__udivsi3>
 80215cc:	0003      	movs	r3, r0
}
 80215ce:	0018      	movs	r0, r3
 80215d0:	46bd      	mov	sp, r7
 80215d2:	bdb0      	pop	{r4, r5, r7, pc}
 80215d4:	080218e8 	.word	0x080218e8

080215d8 <MX_LoRaWAN_Process>:

  /* USER CODE END MX_LoRaWAN_Init_2 */
}

void MX_LoRaWAN_Process(void)
{
 80215d8:	b580      	push	{r7, lr}
 80215da:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 80215dc:	2301      	movs	r3, #1
 80215de:	425b      	negs	r3, r3
 80215e0:	0018      	movs	r0, r3
 80215e2:	f000 f803 	bl	80215ec <UTIL_SEQ_Run>
  /* USER CODE BEGIN MX_LoRaWAN_Process_2 */

  /* USER CODE END MX_LoRaWAN_Process_2 */
}
 80215e6:	46c0      	nop			; (mov r8, r8)
 80215e8:	46bd      	mov	sp, r7
 80215ea:	bd80      	pop	{r7, pc}

080215ec <UTIL_SEQ_Run>:
 * That is the reason why many variables that are used only in that function are declared static.
 * Note: These variables could have been declared static in the function.
 *
 */
void UTIL_SEQ_Run( UTIL_SEQ_bm_t Mask_bm )
{
 80215ec:	b580      	push	{r7, lr}
 80215ee:	b090      	sub	sp, #64	; 0x40
 80215f0:	af00      	add	r7, sp, #0
 80215f2:	6078      	str	r0, [r7, #4]
  /*
   * When this function is nested, the mask to be applied cannot be larger than the first call
   * The mask is always getting smaller and smaller
   * A copy is made of the mask set by UTIL_SEQ_Run() in case it is called again in the task
   */
  super_mask_backup = SuperMask;
 80215f4:	4b72      	ldr	r3, [pc, #456]	; (80217c0 <UTIL_SEQ_Run+0x1d4>)
 80215f6:	681b      	ldr	r3, [r3, #0]
 80215f8:	62bb      	str	r3, [r7, #40]	; 0x28
  SuperMask &= Mask_bm;
 80215fa:	4b71      	ldr	r3, [pc, #452]	; (80217c0 <UTIL_SEQ_Run+0x1d4>)
 80215fc:	681b      	ldr	r3, [r3, #0]
 80215fe:	687a      	ldr	r2, [r7, #4]
 8021600:	401a      	ands	r2, r3
 8021602:	4b6f      	ldr	r3, [pc, #444]	; (80217c0 <UTIL_SEQ_Run+0x1d4>)
 8021604:	601a      	str	r2, [r3, #0]
   * TaskMask that comes from UTIL_SEQ_PauseTask() / UTIL_SEQ_ResumeTask
   * SuperMask that comes from UTIL_SEQ_Run
   * If the waited event is there, exit from  UTIL_SEQ_Run() to return to the
   * waiting task
   */
  local_taskset = TaskSet;
 8021606:	4b6f      	ldr	r3, [pc, #444]	; (80217c4 <UTIL_SEQ_Run+0x1d8>)
 8021608:	681b      	ldr	r3, [r3, #0]
 802160a:	63bb      	str	r3, [r7, #56]	; 0x38
  local_evtset = EvtSet;
 802160c:	4b6e      	ldr	r3, [pc, #440]	; (80217c8 <UTIL_SEQ_Run+0x1dc>)
 802160e:	681b      	ldr	r3, [r3, #0]
 8021610:	637b      	str	r3, [r7, #52]	; 0x34
  local_taskmask = TaskMask;
 8021612:	4b6e      	ldr	r3, [pc, #440]	; (80217cc <UTIL_SEQ_Run+0x1e0>)
 8021614:	681b      	ldr	r3, [r3, #0]
 8021616:	633b      	str	r3, [r7, #48]	; 0x30
  local_evtwaited =  EvtWaited;
 8021618:	4b6d      	ldr	r3, [pc, #436]	; (80217d0 <UTIL_SEQ_Run+0x1e4>)
 802161a:	681b      	ldr	r3, [r3, #0]
 802161c:	62fb      	str	r3, [r7, #44]	; 0x2c
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 802161e:	e090      	b.n	8021742 <UTIL_SEQ_Run+0x156>
  {
    counter = 0U;
 8021620:	2300      	movs	r3, #0
 8021622:	63fb      	str	r3, [r7, #60]	; 0x3c
    /*
     * When a flag is set, the associated bit is set in TaskPrio[counter].priority mask depending
     * on the priority parameter given from UTIL_SEQ_SetTask()
     * The while loop is looking for a flag set from the highest priority maskr to the lower
     */
    while((TaskPrio[counter].priority & local_taskmask & SuperMask)== 0U)
 8021624:	e002      	b.n	802162c <UTIL_SEQ_Run+0x40>
    {
      counter++;
 8021626:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021628:	3301      	adds	r3, #1
 802162a:	63fb      	str	r3, [r7, #60]	; 0x3c
    while((TaskPrio[counter].priority & local_taskmask & SuperMask)== 0U)
 802162c:	4b69      	ldr	r3, [pc, #420]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 802162e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8021630:	00d2      	lsls	r2, r2, #3
 8021632:	58d3      	ldr	r3, [r2, r3]
 8021634:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8021636:	401a      	ands	r2, r3
 8021638:	4b61      	ldr	r3, [pc, #388]	; (80217c0 <UTIL_SEQ_Run+0x1d4>)
 802163a:	681b      	ldr	r3, [r3, #0]
 802163c:	4013      	ands	r3, r2
 802163e:	d0f2      	beq.n	8021626 <UTIL_SEQ_Run+0x3a>
    }

    current_task_set = TaskPrio[counter].priority & local_taskmask & SuperMask;
 8021640:	4b64      	ldr	r3, [pc, #400]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 8021642:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8021644:	00d2      	lsls	r2, r2, #3
 8021646:	58d3      	ldr	r3, [r2, r3]
 8021648:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802164a:	401a      	ands	r2, r3
 802164c:	4b5c      	ldr	r3, [pc, #368]	; (80217c0 <UTIL_SEQ_Run+0x1d4>)
 802164e:	681b      	ldr	r3, [r3, #0]
 8021650:	4013      	ands	r3, r2
 8021652:	627b      	str	r3, [r7, #36]	; 0x24
     * so that the second one can be executed.
     * Note that the first flag is not removed from the list of pending task but just masked by the round_robin mask
     *
     * In the check below, the round_robin mask is reinitialize in case all pending tasks haven been executed at least once
     */
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 8021654:	4a5f      	ldr	r2, [pc, #380]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 8021656:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021658:	00db      	lsls	r3, r3, #3
 802165a:	18d3      	adds	r3, r2, r3
 802165c:	3304      	adds	r3, #4
 802165e:	681b      	ldr	r3, [r3, #0]
 8021660:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021662:	4013      	ands	r3, r2
 8021664:	d107      	bne.n	8021676 <UTIL_SEQ_Run+0x8a>
    {
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 8021666:	4a5b      	ldr	r2, [pc, #364]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 8021668:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802166a:	00db      	lsls	r3, r3, #3
 802166c:	18d3      	adds	r3, r2, r3
 802166e:	3304      	adds	r3, #4
 8021670:	2201      	movs	r2, #1
 8021672:	4252      	negs	r2, r2
 8021674:	601a      	str	r2, [r3, #0]
  /*
   * Read the flag index of the task to be executed
	 * Once the index is read, the associated task will be executed even though a higher priority stack is requested
	 * before task execution.
	 */
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 8021676:	4a57      	ldr	r2, [pc, #348]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 8021678:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802167a:	00db      	lsls	r3, r3, #3
 802167c:	18d3      	adds	r3, r2, r3
 802167e:	3304      	adds	r3, #4
 8021680:	681b      	ldr	r3, [r3, #0]
 8021682:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021684:	4013      	ands	r3, r2
 8021686:	0018      	movs	r0, r3
 8021688:	f000 f8ba 	bl	8021800 <SEQ_BitPosition>
 802168c:	0003      	movs	r3, r0
 802168e:	001a      	movs	r2, r3
 8021690:	4b51      	ldr	r3, [pc, #324]	; (80217d8 <UTIL_SEQ_Run+0x1ec>)
 8021692:	601a      	str	r2, [r3, #0]

    /*
     * remove from the roun_robin mask the task that has been selected to be executed
     */
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 8021694:	4a4f      	ldr	r2, [pc, #316]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 8021696:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021698:	00db      	lsls	r3, r3, #3
 802169a:	18d3      	adds	r3, r2, r3
 802169c:	3304      	adds	r3, #4
 802169e:	681a      	ldr	r2, [r3, #0]
 80216a0:	4b4d      	ldr	r3, [pc, #308]	; (80217d8 <UTIL_SEQ_Run+0x1ec>)
 80216a2:	681b      	ldr	r3, [r3, #0]
 80216a4:	2101      	movs	r1, #1
 80216a6:	4099      	lsls	r1, r3
 80216a8:	000b      	movs	r3, r1
 80216aa:	43db      	mvns	r3, r3
 80216ac:	401a      	ands	r2, r3
 80216ae:	4949      	ldr	r1, [pc, #292]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 80216b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80216b2:	00db      	lsls	r3, r3, #3
 80216b4:	18cb      	adds	r3, r1, r3
 80216b6:	3304      	adds	r3, #4
 80216b8:	601a      	str	r2, [r3, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80216ba:	f3ef 8310 	mrs	r3, PRIMASK
 80216be:	61bb      	str	r3, [r7, #24]
  return(result);
 80216c0:	69bb      	ldr	r3, [r7, #24]

    UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 80216c2:	623b      	str	r3, [r7, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 80216c4:	b672      	cpsid	i
}
 80216c6:	46c0      	nop			; (mov r8, r8)
    /* remove from the list or pending task the one that has been selected to be executed */
    TaskSet &= ~(1U << CurrentTaskIdx);
 80216c8:	4b43      	ldr	r3, [pc, #268]	; (80217d8 <UTIL_SEQ_Run+0x1ec>)
 80216ca:	681b      	ldr	r3, [r3, #0]
 80216cc:	2201      	movs	r2, #1
 80216ce:	409a      	lsls	r2, r3
 80216d0:	0013      	movs	r3, r2
 80216d2:	43da      	mvns	r2, r3
 80216d4:	4b3b      	ldr	r3, [pc, #236]	; (80217c4 <UTIL_SEQ_Run+0x1d8>)
 80216d6:	681b      	ldr	r3, [r3, #0]
 80216d8:	401a      	ands	r2, r3
 80216da:	4b3a      	ldr	r3, [pc, #232]	; (80217c4 <UTIL_SEQ_Run+0x1d8>)
 80216dc:	601a      	str	r2, [r3, #0]
    /* remove from all priority mask the task that has been selected to be executed */
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 80216de:	2301      	movs	r3, #1
 80216e0:	63fb      	str	r3, [r7, #60]	; 0x3c
 80216e2:	e013      	b.n	802170c <UTIL_SEQ_Run+0x120>
    {
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 80216e4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80216e6:	1e5a      	subs	r2, r3, #1
 80216e8:	4b3a      	ldr	r3, [pc, #232]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 80216ea:	00d2      	lsls	r2, r2, #3
 80216ec:	58d1      	ldr	r1, [r2, r3]
 80216ee:	4b3a      	ldr	r3, [pc, #232]	; (80217d8 <UTIL_SEQ_Run+0x1ec>)
 80216f0:	681b      	ldr	r3, [r3, #0]
 80216f2:	2201      	movs	r2, #1
 80216f4:	409a      	lsls	r2, r3
 80216f6:	0013      	movs	r3, r2
 80216f8:	43db      	mvns	r3, r3
 80216fa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80216fc:	3a01      	subs	r2, #1
 80216fe:	4019      	ands	r1, r3
 8021700:	4b34      	ldr	r3, [pc, #208]	; (80217d4 <UTIL_SEQ_Run+0x1e8>)
 8021702:	00d2      	lsls	r2, r2, #3
 8021704:	50d1      	str	r1, [r2, r3]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8021706:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021708:	3b01      	subs	r3, #1
 802170a:	63fb      	str	r3, [r7, #60]	; 0x3c
 802170c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802170e:	2b00      	cmp	r3, #0
 8021710:	d1e8      	bne.n	80216e4 <UTIL_SEQ_Run+0xf8>
 8021712:	6a3b      	ldr	r3, [r7, #32]
 8021714:	617b      	str	r3, [r7, #20]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8021716:	697b      	ldr	r3, [r7, #20]
 8021718:	f383 8810 	msr	PRIMASK, r3
}
 802171c:	46c0      	nop			; (mov r8, r8)
    }
    UTIL_SEQ_EXIT_CRITICAL_SECTION( );

    /* Execute the task */
    TaskCb[CurrentTaskIdx]( );
 802171e:	4b2e      	ldr	r3, [pc, #184]	; (80217d8 <UTIL_SEQ_Run+0x1ec>)
 8021720:	681a      	ldr	r2, [r3, #0]
 8021722:	4b2e      	ldr	r3, [pc, #184]	; (80217dc <UTIL_SEQ_Run+0x1f0>)
 8021724:	0092      	lsls	r2, r2, #2
 8021726:	58d3      	ldr	r3, [r2, r3]
 8021728:	4798      	blx	r3

    local_taskset = TaskSet;
 802172a:	4b26      	ldr	r3, [pc, #152]	; (80217c4 <UTIL_SEQ_Run+0x1d8>)
 802172c:	681b      	ldr	r3, [r3, #0]
 802172e:	63bb      	str	r3, [r7, #56]	; 0x38
    local_evtset = EvtSet;
 8021730:	4b25      	ldr	r3, [pc, #148]	; (80217c8 <UTIL_SEQ_Run+0x1dc>)
 8021732:	681b      	ldr	r3, [r3, #0]
 8021734:	637b      	str	r3, [r7, #52]	; 0x34
    local_taskmask = TaskMask;
 8021736:	4b25      	ldr	r3, [pc, #148]	; (80217cc <UTIL_SEQ_Run+0x1e0>)
 8021738:	681b      	ldr	r3, [r3, #0]
 802173a:	633b      	str	r3, [r7, #48]	; 0x30
    local_evtwaited = EvtWaited;
 802173c:	4b24      	ldr	r3, [pc, #144]	; (80217d0 <UTIL_SEQ_Run+0x1e4>)
 802173e:	681b      	ldr	r3, [r3, #0]
 8021740:	62fb      	str	r3, [r7, #44]	; 0x2c
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8021742:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021744:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8021746:	401a      	ands	r2, r3
 8021748:	4b1d      	ldr	r3, [pc, #116]	; (80217c0 <UTIL_SEQ_Run+0x1d4>)
 802174a:	681b      	ldr	r3, [r3, #0]
 802174c:	4013      	ands	r3, r2
 802174e:	d004      	beq.n	802175a <UTIL_SEQ_Run+0x16e>
 8021750:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8021752:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8021754:	4013      	ands	r3, r2
 8021756:	d100      	bne.n	802175a <UTIL_SEQ_Run+0x16e>
 8021758:	e762      	b.n	8021620 <UTIL_SEQ_Run+0x34>
  }

  /* the set of CurrentTaskIdx to no task running allows to call WaitEvt in the Pre/Post ilde context */
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 802175a:	4b1f      	ldr	r3, [pc, #124]	; (80217d8 <UTIL_SEQ_Run+0x1ec>)
 802175c:	2201      	movs	r2, #1
 802175e:	4252      	negs	r2, r2
 8021760:	601a      	str	r2, [r3, #0]
  UTIL_SEQ_PreIdle( );
 8021762:	f000 f842 	bl	80217ea <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8021766:	f3ef 8310 	mrs	r3, PRIMASK
 802176a:	613b      	str	r3, [r7, #16]
  return(result);
 802176c:	693b      	ldr	r3, [r7, #16]

  UTIL_SEQ_ENTER_CRITICAL_SECTION_IDLE( );
 802176e:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("cpsid i" : : : "memory");
 8021770:	b672      	cpsid	i
}
 8021772:	46c0      	nop			; (mov r8, r8)
  local_taskset = TaskSet;
 8021774:	4b13      	ldr	r3, [pc, #76]	; (80217c4 <UTIL_SEQ_Run+0x1d8>)
 8021776:	681b      	ldr	r3, [r3, #0]
 8021778:	63bb      	str	r3, [r7, #56]	; 0x38
  local_evtset = EvtSet;
 802177a:	4b13      	ldr	r3, [pc, #76]	; (80217c8 <UTIL_SEQ_Run+0x1dc>)
 802177c:	681b      	ldr	r3, [r3, #0]
 802177e:	637b      	str	r3, [r7, #52]	; 0x34
  local_taskmask = TaskMask;
 8021780:	4b12      	ldr	r3, [pc, #72]	; (80217cc <UTIL_SEQ_Run+0x1e0>)
 8021782:	681b      	ldr	r3, [r3, #0]
 8021784:	633b      	str	r3, [r7, #48]	; 0x30
  if ((local_taskset & local_taskmask & SuperMask) == 0U)
 8021786:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021788:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802178a:	401a      	ands	r2, r3
 802178c:	4b0c      	ldr	r3, [pc, #48]	; (80217c0 <UTIL_SEQ_Run+0x1d4>)
 802178e:	681b      	ldr	r3, [r3, #0]
 8021790:	4013      	ands	r3, r2
 8021792:	d106      	bne.n	80217a2 <UTIL_SEQ_Run+0x1b6>
  {
    if ((local_evtset & EvtWaited)== 0U)
 8021794:	4b0e      	ldr	r3, [pc, #56]	; (80217d0 <UTIL_SEQ_Run+0x1e4>)
 8021796:	681b      	ldr	r3, [r3, #0]
 8021798:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 802179a:	4013      	ands	r3, r2
 802179c:	d101      	bne.n	80217a2 <UTIL_SEQ_Run+0x1b6>
    {
      UTIL_SEQ_Idle( );
 802179e:	f000 f81f 	bl	80217e0 <UTIL_SEQ_Idle>
 80217a2:	69fb      	ldr	r3, [r7, #28]
 80217a4:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80217a6:	68fb      	ldr	r3, [r7, #12]
 80217a8:	f383 8810 	msr	PRIMASK, r3
}
 80217ac:	46c0      	nop			; (mov r8, r8)
    }
  }
  UTIL_SEQ_EXIT_CRITICAL_SECTION_IDLE( );

  UTIL_SEQ_PostIdle( );
 80217ae:	f000 f821 	bl	80217f4 <UTIL_SEQ_PostIdle>

  /* restore the mask from UTIL_SEQ_Run() */
  SuperMask = super_mask_backup;
 80217b2:	4b03      	ldr	r3, [pc, #12]	; (80217c0 <UTIL_SEQ_Run+0x1d4>)
 80217b4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80217b6:	601a      	str	r2, [r3, #0]

  return;
 80217b8:	46c0      	nop			; (mov r8, r8)
}
 80217ba:	46bd      	mov	sp, r7
 80217bc:	b010      	add	sp, #64	; 0x40
 80217be:	bd80      	pop	{r7, pc}
 80217c0:	20008010 	.word	0x20008010
 80217c4:	200081fc 	.word	0x200081fc
 80217c8:	20008200 	.word	0x20008200
 80217cc:	2000800c 	.word	0x2000800c
 80217d0:	20008204 	.word	0x20008204
 80217d4:	20008228 	.word	0x20008228
 80217d8:	20008208 	.word	0x20008208
 80217dc:	2000820c 	.word	0x2000820c

080217e0 <UTIL_SEQ_Idle>:
  UTIL_SEQ_Run(~TaskId_bm);
  return;
}

__WEAK void UTIL_SEQ_Idle( void )
{
 80217e0:	b580      	push	{r7, lr}
 80217e2:	af00      	add	r7, sp, #0
  return;
 80217e4:	46c0      	nop			; (mov r8, r8)
}
 80217e6:	46bd      	mov	sp, r7
 80217e8:	bd80      	pop	{r7, pc}

080217ea <UTIL_SEQ_PreIdle>:

__WEAK void UTIL_SEQ_PreIdle( void )
{
 80217ea:	b580      	push	{r7, lr}
 80217ec:	af00      	add	r7, sp, #0
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
 80217ee:	46c0      	nop			; (mov r8, r8)
}
 80217f0:	46bd      	mov	sp, r7
 80217f2:	bd80      	pop	{r7, pc}

080217f4 <UTIL_SEQ_PostIdle>:

__WEAK void UTIL_SEQ_PostIdle( void )
{
 80217f4:	b580      	push	{r7, lr}
 80217f6:	af00      	add	r7, sp, #0
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
 80217f8:	46c0      	nop			; (mov r8, r8)
}
 80217fa:	46bd      	mov	sp, r7
 80217fc:	bd80      	pop	{r7, pc}
	...

08021800 <SEQ_BitPosition>:
 * @brief return the position of the first bit set to 1
 * @param Value 32 bit value
 * @retval bit position
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
 8021800:	b580      	push	{r7, lr}
 8021802:	b084      	sub	sp, #16
 8021804:	af00      	add	r7, sp, #0
 8021806:	6078      	str	r0, [r7, #4]
uint8_t n = 0U;
 8021808:	210f      	movs	r1, #15
 802180a:	187b      	adds	r3, r7, r1
 802180c:	2200      	movs	r2, #0
 802180e:	701a      	strb	r2, [r3, #0]
uint32_t lvalue = Value;
 8021810:	687b      	ldr	r3, [r7, #4]
 8021812:	60bb      	str	r3, [r7, #8]

  if ((lvalue & 0xFFFF0000U) == 0U)  { n  = 16U; lvalue <<= 16U;  }
 8021814:	68bb      	ldr	r3, [r7, #8]
 8021816:	0c1b      	lsrs	r3, r3, #16
 8021818:	041b      	lsls	r3, r3, #16
 802181a:	d105      	bne.n	8021828 <SEQ_BitPosition+0x28>
 802181c:	187b      	adds	r3, r7, r1
 802181e:	2210      	movs	r2, #16
 8021820:	701a      	strb	r2, [r3, #0]
 8021822:	68bb      	ldr	r3, [r7, #8]
 8021824:	041b      	lsls	r3, r3, #16
 8021826:	60bb      	str	r3, [r7, #8]
  if ((lvalue & 0xFF000000U) == 0U)  { n +=  8U; lvalue <<=  8U;  }
 8021828:	68bb      	ldr	r3, [r7, #8]
 802182a:	0e1b      	lsrs	r3, r3, #24
 802182c:	061b      	lsls	r3, r3, #24
 802182e:	d108      	bne.n	8021842 <SEQ_BitPosition+0x42>
 8021830:	220f      	movs	r2, #15
 8021832:	18bb      	adds	r3, r7, r2
 8021834:	18ba      	adds	r2, r7, r2
 8021836:	7812      	ldrb	r2, [r2, #0]
 8021838:	3208      	adds	r2, #8
 802183a:	701a      	strb	r2, [r3, #0]
 802183c:	68bb      	ldr	r3, [r7, #8]
 802183e:	021b      	lsls	r3, r3, #8
 8021840:	60bb      	str	r3, [r7, #8]
  if ((lvalue & 0xF0000000U) == 0U)  { n +=  4U; lvalue <<=  4U;  }
 8021842:	68bb      	ldr	r3, [r7, #8]
 8021844:	0f1b      	lsrs	r3, r3, #28
 8021846:	071b      	lsls	r3, r3, #28
 8021848:	d108      	bne.n	802185c <SEQ_BitPosition+0x5c>
 802184a:	220f      	movs	r2, #15
 802184c:	18bb      	adds	r3, r7, r2
 802184e:	18ba      	adds	r2, r7, r2
 8021850:	7812      	ldrb	r2, [r2, #0]
 8021852:	3204      	adds	r2, #4
 8021854:	701a      	strb	r2, [r3, #0]
 8021856:	68bb      	ldr	r3, [r7, #8]
 8021858:	011b      	lsls	r3, r3, #4
 802185a:	60bb      	str	r3, [r7, #8]

  n += SEQ_clz_table_4bit[lvalue >> (32-4)];
 802185c:	68bb      	ldr	r3, [r7, #8]
 802185e:	0f1b      	lsrs	r3, r3, #28
 8021860:	4a08      	ldr	r2, [pc, #32]	; (8021884 <SEQ_BitPosition+0x84>)
 8021862:	5cd1      	ldrb	r1, [r2, r3]
 8021864:	200f      	movs	r0, #15
 8021866:	183b      	adds	r3, r7, r0
 8021868:	183a      	adds	r2, r7, r0
 802186a:	7812      	ldrb	r2, [r2, #0]
 802186c:	188a      	adds	r2, r1, r2
 802186e:	701a      	strb	r2, [r3, #0]

  return (uint8_t)(31U-n);
 8021870:	183b      	adds	r3, r7, r0
 8021872:	781b      	ldrb	r3, [r3, #0]
 8021874:	221f      	movs	r2, #31
 8021876:	1ad3      	subs	r3, r2, r3
 8021878:	b2db      	uxtb	r3, r3
}
 802187a:	0018      	movs	r0, r3
 802187c:	46bd      	mov	sp, r7
 802187e:	b004      	add	sp, #16
 8021880:	bd80      	pop	{r7, pc}
 8021882:	46c0      	nop			; (mov r8, r8)
 8021884:	08021968 	.word	0x08021968

08021888 <__libc_init_array>:
 8021888:	b570      	push	{r4, r5, r6, lr}
 802188a:	2600      	movs	r6, #0
 802188c:	4c0c      	ldr	r4, [pc, #48]	; (80218c0 <__libc_init_array+0x38>)
 802188e:	4d0d      	ldr	r5, [pc, #52]	; (80218c4 <__libc_init_array+0x3c>)
 8021890:	1b64      	subs	r4, r4, r5
 8021892:	10a4      	asrs	r4, r4, #2
 8021894:	42a6      	cmp	r6, r4
 8021896:	d109      	bne.n	80218ac <__libc_init_array+0x24>
 8021898:	2600      	movs	r6, #0
 802189a:	f000 f819 	bl	80218d0 <_init>
 802189e:	4c0a      	ldr	r4, [pc, #40]	; (80218c8 <__libc_init_array+0x40>)
 80218a0:	4d0a      	ldr	r5, [pc, #40]	; (80218cc <__libc_init_array+0x44>)
 80218a2:	1b64      	subs	r4, r4, r5
 80218a4:	10a4      	asrs	r4, r4, #2
 80218a6:	42a6      	cmp	r6, r4
 80218a8:	d105      	bne.n	80218b6 <__libc_init_array+0x2e>
 80218aa:	bd70      	pop	{r4, r5, r6, pc}
 80218ac:	00b3      	lsls	r3, r6, #2
 80218ae:	58eb      	ldr	r3, [r5, r3]
 80218b0:	4798      	blx	r3
 80218b2:	3601      	adds	r6, #1
 80218b4:	e7ee      	b.n	8021894 <__libc_init_array+0xc>
 80218b6:	00b3      	lsls	r3, r6, #2
 80218b8:	58eb      	ldr	r3, [r5, r3]
 80218ba:	4798      	blx	r3
 80218bc:	3601      	adds	r6, #1
 80218be:	e7f2      	b.n	80218a6 <__libc_init_array+0x1e>
 80218c0:	08021978 	.word	0x08021978
 80218c4:	08021978 	.word	0x08021978
 80218c8:	0802197c 	.word	0x0802197c
 80218cc:	08021978 	.word	0x08021978

080218d0 <_init>:
 80218d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80218d2:	46c0      	nop			; (mov r8, r8)
 80218d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80218d6:	bc08      	pop	{r3}
 80218d8:	469e      	mov	lr, r3
 80218da:	4770      	bx	lr

080218dc <_fini>:
 80218dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80218de:	46c0      	nop			; (mov r8, r8)
 80218e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80218e2:	bc08      	pop	{r3}
 80218e4:	469e      	mov	lr, r3
 80218e6:	4770      	bx	lr
